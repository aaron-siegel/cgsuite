/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * java
 *
 * Created on Jan 30, 2011, 10:55:50 AM
 */

package org.cgsuite.ui.worksheet;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.List;
import javax.swing.Box;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JViewport;
import javax.swing.Scrollable;
import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.Token;
import org.cgsuite.lang.CgsuiteLexer;
import org.cgsuite.lang.CgsuiteObject;
import org.cgsuite.lang.CgsuiteParser;
import org.cgsuite.lang.CgsuiteTree;
import org.cgsuite.lang.CgsuiteTreeAdaptor;
import org.cgsuite.lang.Domain;
import org.cgsuite.lang.InputException;

/**
 *
 * @author asiegel
 */
public class WorksheetPanel extends javax.swing.JPanel implements Scrollable
{
    /** Creates new form WorksheetPanel */
    public WorksheetPanel()
    {
        initComponents();
        addNewCell();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 255, 255));
        setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.Y_AXIS));
    }// </editor-fold>//GEN-END:initComponents

    private void addNewCell()
    {
        JLabel label = new JLabel("> ");
        label.setFont(new Font("Monospaced", Font.PLAIN, 12));
        label.setAlignmentY(Component.TOP_ALIGNMENT);
        EmbeddedTextArea textArea = new EmbeddedTextArea();
        textArea.addKeyListener(new KeyAdapter() {
            public void keyPressed(KeyEvent evt) { cellKeyPressed(evt); }
        });
        /*
        textArea.addFocusListener(new FocusAdapter() {
            public void focusGained(FocusEvent evt) { cellFocusGained(evt); }
        });
         */
        textArea.setAlignmentY(Component.TOP_ALIGNMENT);
//        textArea.addMouseListener(MainFrame.getMainFrame().editPopupListener);
        Box box = Box.createHorizontalBox();
        box.add(label);
        box.add(textArea);
        box.setAlignmentX(Component.LEFT_ALIGNMENT);
        add(box);
    }
    
    private void cellKeyPressed(KeyEvent evt)
    {
        EmbeddedTextArea source = (EmbeddedTextArea) evt.getSource();
        java.awt.Component[] components = getComponents();
        int index;
        for (index = 0; index < components.length; index++)
        {
            if (components[index] instanceof Box &&
                ((Box) components[index]).getComponent(1) == source)
            {
                break;
            }
        }

        switch (evt.getKeyCode())
        {
            case KeyEvent.VK_TAB:
                if (evt.getModifiers() == 0)
                {
                    evt.consume();
                    for (index++; index < components.length; index++)
                    {
                        if (components[index] instanceof Box)
                        {
                            ((Box) components[index]).getComponent(1).requestFocusInWindow();
                            break;
                        }
                    }
                }
                else if (evt.getModifiers() == KeyEvent.SHIFT_MASK)
                {
                    evt.consume();
                    for (index--; index >= 0; index--)
                    {
                        if (components[index] instanceof Box)
                        {
                            ((Box) components[index]).getComponent(1).requestFocusInWindow();
                            break;
                        }
                    }
                }
                break;

            case KeyEvent.VK_ENTER:
                if (evt.getModifiers() == 0)
                {
                    evt.consume();
                    if (!source.getText().equals(""))
                    {
                        processCommand(source);
                    }
                }
                else if (evt.getModifiers() == KeyEvent.SHIFT_MASK)
                {
                    evt.consume();
                    source.insert("\n", source.getCaretPosition());
                }
                break;

            default:
                break;
        }
    }
    
    private void processCommand(EmbeddedTextArea source)
    {
        Output[] output = null;
        CgsuiteTree tree = null;
        try
        {
            Domain.CLASS_DOMAIN.refresh();
            ANTLRStringStream input = new ANTLRStringStream(source.getText());
            CgsuiteLexer lexer = new CgsuiteLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            CgsuiteParser parser = new CgsuiteParser(tokens);
            parser.setTreeAdaptor(new CgsuiteTreeAdaptor());
            CgsuiteParser.script_return r = parser.script();
            tree = (CgsuiteTree) r.getTree();

            if (parser.getNumberOfSyntaxErrors() > 0)
            {
                String firstErrorMsg = parser.getErrors().get(0).getMessage();
                String[] linecol = firstErrorMsg.substring(5, firstErrorMsg.indexOf(' ', 5)).split(":");
                int line = Integer.parseInt(linecol[0]);
                int col = Integer.parseInt(linecol[1]);
                output = getLineColOutput(source.getText(), line, col, "Syntax error.");
                getToolkit().beep();
            }
            else
            {
                CgsuiteObject retval = Domain.CLASS_DOMAIN.script(tree);
                output = new Output[]
                {
                    new CoreIOHandler().createOutput(retval.invoke("Simplify"))
                };
            }
        }
        catch (Exception exc)
        {
            output = getExceptionOutput(source.getText(), exc, false);
            getToolkit().beep();
        }

        // Find this component.
        int index = findIndex(source, false) + 1;
        Component[] components = getComponents();

        for (int i = index; i < components.length && components[i] instanceof OutputBox; i++)
        {
            remove(index);
        }

        if (output != null)
        {
            for (int i = 0; i < output.length; i++)
            {
                OutputBox outputBox = new OutputBox();
                outputBox.setOutput(output[i]);
                outputBox.setWorksheetWidth(getWidth());
                outputBox.setAlignmentX(Component.LEFT_ALIGNMENT);
                add(outputBox, index + i);
            }
            advanceToNext(index + output.length);
        }

        repaint();
        getParent().getParent().validate();
    }

    // Finds the component index of eta.  If skipPastOutput is true, finds the
    // index immediately following all output after eta.
    private int findIndex(EmbeddedTextArea eta, boolean skipPastOutput)
    {
        Component components[] = getComponents();
        int index;
        for (index = 0; index < components.length; index++)
        {
            if (components[index] instanceof Box &&
                ((Box) components[index]).getComponent(1) == eta)
            {
                break;
            }
        }
        if (index == components.length)
        {
            index = -1;
        }
        if (skipPastOutput)
        {
            do
            {
                index++;
            } while (index < components.length && components[index] instanceof OutputBox);
        }
        return index;
    }

    private void advanceToNext(int index)
    {
        if (index == getComponentCount())
        {
            add(Box.createVerticalStrut(10));
            addNewCell();
        }
        index++;    // Skip the vertical strut
        updateComponentSizes();
        validate();
        Point topLeft = getComponent(index).getLocation();
        Point bottomLeft = new Point(topLeft.x, topLeft.y + getComponent(index).getHeight());
        if (!((JViewport) getParent()).getViewRect().contains(bottomLeft))
        {
            ((JScrollPane) getParent().getParent()).getHorizontalScrollBar().setValue(0);
            ((JScrollPane) getParent().getParent()).getVerticalScrollBar().setValue
                (bottomLeft.y - ((JViewport) getParent()).getHeight());
        }
        ((Box) getComponent(index)).getComponent(1).requestFocusInWindow();
        validate();
    }

    private void insertOutput(Output output, int index)
    {
        OutputBox outputBox = new OutputBox();
        outputBox.setOutput(output);
        outputBox.setWorksheetWidth(getWidth());
        outputBox.setAlignmentX(Component.LEFT_ALIGNMENT);
        add(outputBox, index);
        getParent().getParent().validate();
    }

    public void updateComponentSizes()
    {
        if (getComponentCount() == 0)
        {
            return;
        }
        int width = ((JScrollPane) getParent().getParent()).getViewport().getExtentSize().width;
        java.awt.Component components[] = getComponents();
        for (int index = 0; index < components.length; index++)
        {
            if (components[index] instanceof Box)
            {
                Box box = (Box) components[index];
                EmbeddedTextArea eta = (EmbeddedTextArea) box.getComponent(1);
                int etaW = width - box.getComponent(0).getWidth();
                eta.setMinimumSize(new Dimension(etaW, eta.getMinimumSize().height));
                eta.setMaximumSize(new Dimension(etaW, eta.getMaximumSize().height));
                eta.setSize(etaW, eta.getHeight());
                eta.invalidate();
            }
            if (components[index] instanceof OutputBox)
            {
                OutputBox outputBox = (OutputBox) components[index];
                outputBox.setWorksheetWidth(width);
                outputBox.invalidate();
            }
        }
        getParent().getParent().validate();
    }

    private static List<Output> getStackOutput(String input, InputException exc)
    {
        List<Output> output = new ArrayList<Output>();
        output.add(errorOutput(exc.getMessage()));
        if (exc.getCause() != null)
        {
            output.add(errorOutput("  caused by " + exc.getCause().getClass().getName()));
            StackTraceElement[] javaStackTrace = exc.getCause().getStackTrace();
            for (int i = 0; i < 3 && i < javaStackTrace.length; i++)
            {
                StackTraceElement ste = javaStackTrace[i];
                output.add(errorOutput("  at " + ste.getClassName() + " line " + ste.getLineNumber() + "\n"));
            }
            if (javaStackTrace.length > 3)
            {
                output.add(errorOutput("  ......"));
            }
        }
        for (Token token : exc.getTokenStack())
        {
            String source = token.getInputStream().getSourceName();
            if (source == null)
            {
                output.add(errorOutput("  at worksheet input:\n"));
                output.addAll(Arrays.asList(getLineColOutput(input, token.getLine(), token.getCharPositionInLine(), "")));
            }
            else
            {
                output.add(errorOutput(
                    "  at " + source + " line " + token.getLine() + ":" + token.getCharPositionInLine() + "\n"
                    ));
            }
        }
        return output;
    }

    private static Output[] getExceptionOutput(String input, Exception exc, boolean includeLine)
    {
        int line = 0, col = 0;

        if (exc instanceof RecognitionException)
        {
            line = ((RecognitionException) exc).line;
            col  = ((RecognitionException) exc).charPositionInLine;
        }
        else if (exc instanceof InputException)
        {
            return getStackOutput(input, (InputException) exc).toArray(new Output[0]);
        }
        else
        {
            StringWriter sw = new StringWriter();
            exc.printStackTrace(new PrintWriter(sw));
            String[] strings = sw.toString().split("\n");
            Output[] output = new Output[strings.length];
            for (int i = 0; i < strings.length; i++)
            {
                output[i] = errorOutput(strings[i]);
            }
            return output;
        }

        String message =
            (includeLine && line > 0 ? "Error (Line " + line + ":" + col + "): " : "")
            + getMessageForException(exc);

        if (input == null || line <= 0)
        {
            return new Output[] { new StyledTextOutput(message) };
        }
        else
        {
            return getLineColOutput(input, line, col, message);
        }
    }

    private static Output[] getLineColOutput(String input, int line, int col, String message)
    {
        Output[] output = new Output[3];
        // Advance to the point in the input string where the exceptional line begins.
        int lineStartIndex = 0;
        for (int i = 1; i < line; i++)
        {
            lineStartIndex = input.indexOf('\n', lineStartIndex) + 1;
        }
        int lineEndIndex = input.indexOf('\n', lineStartIndex);
        // Next get the part of the input string that has the error.
        output[0] = errorOutput(
            "  " + input.substring(
                Math.max(lineStartIndex, lineStartIndex + col - 24),
                Math.min(lineEndIndex == -1 ? input.length() : lineEndIndex, lineStartIndex + col + 25)
            ));
        String pointerStr = "  ";
        for (int i = 0; i < Math.min(col - 1, 22); i++)
        {
            pointerStr += " ";
        }
        output[1] = errorOutput(pointerStr + (col == 1 ? "^^" : "^^^"));
        output[2] = new StyledTextOutput(message);
        return output;
    }

    private static Output errorOutput(String msg)
    {
        return new StyledTextOutput(
            EnumSet.of(StyledTextOutput.Style.FACE_MONOSPACED, StyledTextOutput.Style.COLOR_RED),
            msg
            );
    }

    private static String getMessageForException(Exception exc)
    {
        if (exc instanceof InputException)
        {
            return exc.getMessage();
        }
        else if (exc instanceof antlr.NoViableAltException &&
                 ((antlr.NoViableAltException) exc).token.getType() == CgsuiteLexer.SLASHES)
        {
            return "Syntax error: Every slash | must be enclosed in braces { }.";
        }
        else
        {
            return "Syntax error.";
        }
    }
    
    @Override
    public Dimension getPreferredScrollableViewportSize()
    {
        return getPreferredSize();
    }

    @Override
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction)
    {
        return 40;
    }

    @Override
    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction)
    {
        return 200;
    }

    @Override
    public boolean getScrollableTracksViewportWidth()
    {
        return false;
    }

    @Override
    public boolean getScrollableTracksViewportHeight()
    {
        return false;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

}
