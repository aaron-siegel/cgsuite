class DayN

    var allSmall, reduced;
    var elements;
    
    var upcov, lowcov;

    method DayN(birthday, allSmall ? false, reduced ? false)

        upcov := {=>};
        lowcov := {=>};

        if birthday == 0 then
            elements := {0};
        else
            elements := {0};
            prev := DayN(birthday-1, allSmall, reduced);
            prevac := prev.Antichains;
            if allSmall then
                prevac.Remove({});  // Remove empty set as a possibility
            end
            for lo in prevac do
                for ro in prevac do
                    if reduced then
                        elements.Add({lo|ro}.Rcf);
                    else
                        elements.Add({lo|ro});
                    end
                end
            end
        end

    end

    property Size.get

        return elements.Size;

    end

    property Elements.get

        return elements;

    end

    property Antichains.get

        antichains := {{}};

        for g in Elements do

            newAntichains := {};

            for ac in antichains do
                if not IsComparableToAny(ac, g) then
                    newac := ac;
                    newac.Add(g);
                    newAntichains.Add(newac);
                end
            end

            antichains.AddAll(newAntichains);

        end;

        return antichains;

    end

    method IsComparableToAny(ac, g)

        if reduced then
            for h in ac do
                if not g.Heat(*) <> h.Heat(*) then
                    return true;
                end
            end
        else
            for h in ac do
                if not g <> h then
                    return true;
                end
            end
        end

        return false;

    end

    method UpperCovers(g)

        upcov := {};

        for h in elements do
            if h > g then
                isNew := true;
                dominated := {};
                for j in upcov do
                    if h > j then
                        isNew := false;
                        break;
                    elseif j > h then
                        dominated.Add(j);
                    end
                end;
                if isNew then
                    upcov.RemoveAll(dominated);
                    upcov.Add(h);
                end
            end
        end

        return upcov;

    end

    property JoinIrreducibles.get

        ji := {};

        for g in elements do
            if UpperCovers(-g).Size == 1 then
                ji.Add(g);
            end
        end

        return ji;

    end

end