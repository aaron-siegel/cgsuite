/*
 * RacingRooks.cgs
 *
 * Racing Rooks is played on a grid with black and white rooks, vacant spaces, and blocked spaces. 
 * A move for Left is to move one of the black rooks at least one square, stopping when blocked by
 * the board edge, another rook, or a blocked space (no captures are made). After a move all the
 * squares from where the move began to just before where it finished are blocked.
 *
 * In an alternative version, short moves are allowed, i.e. the rook can stop before being blocked.
 *
 * Examples:
 * g := examples.RacingRooks("x...x|.....|.....|.....|o...."); (Long moves version)
 * g := examples.RacingRooks("x...x|.....|.....|.....|o....", true); (Short moves version)
 * 
 * Created by malbert on 28/07/2011
 */

class RacingRooks extends GridGame

    var shortMoves;

    method RacingRooks(grid, ShortMoves ? false)
        this.GridGame(grid);
        this.shortMoves := ShortMoves;
    end

    method Options(Player player)

        options := {};

        us := player.Ordinal;
        
        for m from 1 to this.grid.NumRows do
            for n from 1 to this.grid.NumColumns do
                if this.grid[m,n] == us then
                    for d in Direction.Orthogonal do
                        gap := 1;
                        while this.grid[m + gap*d.RowShift, n + gap*d.ColumnShift] == 0 do
                            if this.shortMoves or this.grid[m + (gap+1)*d.RowShift, n + (gap+1)*d.ColumnShift] != 0 then
                                copy := this.grid;
                                copy[m + gap*d.RowShift, n + gap*d.ColumnShift] := us;
                                g := gap-1;
                                while g >= 0 do
                                    copy[m + g*d.RowShift, n + g*d.ColumnShift] := 3;
                                    g := g-1;
                                end
                                options.Add(RacingRooks(copy, this.shortMoves));
                            end
                            gap := gap+1;
                        end
                    end
                end
            end
        end

        return options;

    end
    
    override property CanonicalForm.get

        components := this.grid.Decompose(3);
        g := 0;
        for grid in components do
            g := g + RacingRooks(grid.SymmetryInvariantRepresentation, this.shortMoves).super.CanonicalForm;
        end
        return g;

    end

    
    property CharMap.get
        return ".xo#";
    end
    
    property Icons.get
        return
        [
            GridIcon.Blank,
            GridIcon.BlackRook,
            GridIcon.WhiteRook,
            GridIcon.Grayed
        ];
    end

end