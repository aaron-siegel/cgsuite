class CanonicalShortGame extends Game : java "org.cgsuite.lang.game.CanonicalShortGame"

    override method op+(obj) : java "add";
    override method op-(obj) : java "subtract";
    override method op neg() : java "negate";
    method op<=(CanonicalShortGame other) : java "leq";
    override method op==(CanonicalShortGame other)
        return this <= other and other <= this;
    end
    override property CanonicalForm.get
        return this;
    end
    method Heat(CanonicalShortGame t) : java "heat";
    method Overheat(CanonicalShortGame s, CanonicalShortGame t) : java "overheat";
    method Cool(Number t) : java "cool";
    method NortonProduct(CanonicalShortGame h) : java "nortonMultiply";
    method ConwayProduct(CanonicalShortGame h) : java "conwayMultiply";
    method OrdinalSum(CanonicalShortGame h) : java "ordinalSum";

    method Options(Player player)
        if player == Player.Left then
            return LeftOptions;
        else
            return RightOptions;
        end
    end

    override property AtomicWeight.get : java "atomicWeight";
    override property Birthday.get : java "birthday";
             property Diversity.get : java "diversity";
    override property Freeze.get : java "freeze";
             property Incentives.get : java "incentives";
    override property IsAllSmall.get : java "isAllSmall";
             property IsEven.get : java "isEven";
             property IsEvenTempered.get : java "isEvenTempered";
    override property IsInfinitesimal.get : java "isInfinitesimal";
    override property IsInteger.get : java "isInteger";
    override property IsNimber.get : java "isNimber";
    override property IsNumber.get : java "isNumber";
    override property IsNumberish.get : java "isNumberish";
    override property IsNumberTiny.get : java "isNumberTiny";
    override property IsNumberUpStar.get : java "isNumberUpStar";
             property IsOdd.get : java "isOdd";
             property IsOddTempered.get : java "isOddTempered";
    override property IsUptimal.get : java "isUptimal";
             property LeftIncentives.get : java "leftIncentives";
    override property LeftOptions.get : java "getLeftOptions";
    override property LeftStop.get : java "leftStop";
    override property Mean.get : java "mean";
    override property Rcf.get : java "rcf";
             property RightIncentives.get : java "rightIncentives";
    override property RightOptions.get : java "getRightOptions";
    override property RightStop.get : java "rightStop";
             property StopCount.get : java "stopCount";
    override property Temperature.get : java "temperature";
    override property Thermograph.get : java "thermograph";
    override property ToString.get : java "toString";
    override property UptimalExpansion.get : java "uptimalExpansion";
    
    property Companion.get
    
        if (this-Mean).IsNimber and (Mean != 0 or Birthday >= 2) then
            return this;
        end
    
        clo := setof(g.Companion for g in LeftOptions);
        cro := setof(g.Companion for g in RightOptions);
        if this >= 0 then
            clo.Add(0);
        end
        if this <= 0 then
            cro.Add(0);
        end
        return {clo|cro};
        
    end
    
    property IsReduced.get
        return this == Rcf;
    end
    
    property Miny.get
        return { this | 0 || 0 };
    end
    
    override property Outcome.get
    
        if this == 0 then
            return OutcomeClass.P;
        elseif this >= 0 then
            return OutcomeClass.L;
        elseif this <= 0 then
            return OutcomeClass.R;
        else
            return OutcomeClass.N;
        end
    
    end
    
    method Pow(DyadicRational x)
    
        if x < 1 then
            error("Exponent must be >= 1.");
        end
        
        ro := RightOptions.AnyElement;
        
        if ro === nil or this != {0|ro} then
            error("Base must be of the form {0|H}.");
        end
        
        if x is Integer then
            // This is equal to PowTo(x) - PowTo(x-1) in the case of an integer and is much faster
            // to calculate.  Perhaps it's the right definition even in the non-integer case.
            // Still a bit of unresolved theory.
            return { 0 | ro - PowTo(x-1) };
        else
            return PowTo(x) - PowTo(x-1);
        end
    
    end
    
    method PowTo(DyadicRational x)
    
        // {0|H}.PowTo(x) is always defined recursively by
        // { PowTo(x^L) | H, PowTo(x^R) }.  However, we
        // apply some shortcuts using OrdinalSum for a
        // much more efficient calculation.
    
        if x < 0 then
            error("Exponent must be non-negative.");
        end
    
        ro := RightOptions.AnyElement;
        
        if ro === nil or this != {0|ro} then
            error("Base must be of the form {0|H}.");
        end
        
        if x >= 1 then
            // As given by [Moews 1996].
            return OrdinalSum(x-1);
        else
            /* This case is interesting and surprising.  It's equal to OrdinalSum(y), where y is the
               "blowup" of x-1, obtained by removing Left's moves to -1 from the canonical form of x-1.
               For example, if x == 3/8, then
               
               x-1 == -5/8 == {-3/4|-1/2} == { {-1||-1|0} ||| {-1|0} }
               
               so Blowup(x-1) == { {.||.|0} ||| {.|0} } == { -2 | -1 } = -3/2.  Sure enough,
               
               ^.OrdinalSum(-3/2) == ^.PowTo(3/8) == *.OrdinalSum(3/8) + *
               
               agreeing with the other definitions of ^.PowTo(3/8). */
            
            return OrdinalSum(CanonicalShortGame.Blowup(x-1));
        end
    
    end
    
    property Tiny.get
        return { 0 || 0 | -this };
    end
    
    static method Blowup(DyadicRational x)
    
        if x == 0 then
            return 0;
        end
        
        xl := x.LeftOptions.AnyElement;
        xr := x.RightOptions.AnyElement;
        
        if xl == -1 then
            return { | CanonicalShortGame.Blowup(xr) };
        else
            return { CanonicalShortGame.Blowup(xl) | CanonicalShortGame.Blowup(xr) };
        end
    
    end

end
