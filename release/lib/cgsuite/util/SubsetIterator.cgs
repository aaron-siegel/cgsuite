/*
 * SubsetIterator.cgs
 * 
 * Iterator for subsets of a given set. Takes one or two parameters, with just
 * one (a set or list) it iterates over all the subsets, in size order.
 * With two parameters, one an integer, the other a set or list (in either
 * order) it iterates over the subsets of that size. Note that if a list
 * argument has repeated elements, then these may occur up to their
 * multiplicities. However, the iterator will also return some duplicates in
 * this case, as they are treated as being distinct.
 *
 * Examples:
 * it := SubsetIterator([0, *, ^]);
 * while it.HasNext do Worksheet.Print(it.Next); end;
 *
 * Created by malbert on 4/08/2011
 */

mutable class SubsetIterator extends Iterator

    var valueList;
    var subsetSize;
    var indexSeq;
    var allSubsets;
    var iterators;
    
    method SubsetIterator(arg1 ? nil, arg2 ? nil) 
        
        if arg1 is Integer then
            subsetSize := arg1;
            vals := arg2;
        else
            vals := arg1;
            subsetSize := arg2;
        end
        
        allSubsets := not subsetSize is Integer;
        
        if vals is Set then
            valueList := listof(x for x in vals);
        elseif vals is List then
            valueList := vals;
        else
            error("SubsetIterator requires a Set or List collection.");
        end
        
        if allSubsets then
            iterators := IteratorSequence(listof(SubsetIterator(i, valueList) for i from 0 to valueList.Length));
        elseif subsetSize > valueList.Length or subsetSize < 0 then
            indexSeq := nil;
        else
            indexSeq := listof(i for i from 1 to subsetSize);
        end
        
    end
    
    override mutable property HasNext.get
       
        if not allSubsets then 
                return indexSeq != nil;
        end
       
        return iterators.HasNext;
       
    end
    
    override mutable property Next.get
    
        if allSubsets then
            return iterators.Next;
        end
    
        result := {};
        for i from 1 to indexSeq.Length do    
            result.Add(valueList[indexSeq[i]]);
        end
        
        for i from indexSeq.Length to 1 by -1 while indexSeq[i] == valueList.Length - indexSeq.Length + i do end;
        
        if i == 0 then
            indexSeq := nil;
        else
            indexSeq[i] := indexSeq[i] + 1;
            for j from i+1 to indexSeq.Length do
                indexSeq[j] := indexSeq[j-1] + 1;
            end
        end
        
        return result;
    end

end