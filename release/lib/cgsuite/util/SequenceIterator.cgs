/*
 * SequenceIterator.cgs
 *
 * An iterator for all sequences of length n from a set or list of values. A common
 * trick is employed -- the sequence currently stored (seq) is actually the
 * next one to be returned. When Next is called, seq is copied and then updated.
 * The update is such that when we have reached the last sequence, the state
 * of seq is clearly incorrect (it is one element too long). This means that
 * the HasNext test is very simple.
 *
 * Created by malbert on 4/08/2011
 */

mutable class SequenceIterator extends Iterator

    var valueList;
    var n;
    var seq;
    
    method SequenceIterator(Integer n, Set values ? nil, List valueList ? nil)
        if (values != nil) and (valueList != nil) then
            error("Sequence iterator can be constructed from either a set or a list, not both.");
        end
        
        if (values == nil) and (valueList == nil) then
            error("A set or list of values must be specified for a Sequence iterator.");
        end
        
        if (values != nil) then
            valueList := listof(x for x in values);
        end
        
        seq := listof(1 for x from 1 to n);
    end
    
    override property HasNext.get
        seq.Length == n and (n == 0 or seq[1] <= valueList.Length);
    end
    
    override property Next.get
        result := seq;
        i := 1;
        while i <= seq.Length and seq[i] == valueList.Length do
            seq[i] := 1;
            i := i+1;
        end
        if i <= seq.Length then
            seq[i] := seq[i] + 1;
        else
            seq.Add(1); // We are done, update to an inconsistent state
        end
        return listof(valueList[i] for i in result);
    end
    

end