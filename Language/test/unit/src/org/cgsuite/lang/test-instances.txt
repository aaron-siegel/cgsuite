
// Basic script processing

Simple echo                     \ 0 \ 0 \
Variable assignment             \ g := 0 \ 0 \
Variable retrieval              \ g \ 0 \
Multivee/identifier parse check \ vvvvx := vvvvv \ v5 \

// Arithmetic

Integer addition                \ 3+5 \ 8 \
Integer multiplication          \ 3*5 \ 15 \
Integer exponentiation          \ 3^5 \ 243 \
Rational number                 \ 4/6 \ 2/3 \
Rational exponentiation         \ (1/2)^4 \ 1/16 \
Negative power                  \ 2^(-4) \ 1/16 \
Integer modulus                 \ 17 % 5 \ 2 \
Rational modulus                \ (17/6) % (1/3) \ 1/6 \
Nimber addition                 \ *3+*5 \ *6 \
Nimber operator                 \ *(3+5) \ *8 \
Ups                             \ ^^^^^^+vvv*+^19*3+v14 \ ^8*2 \

Integer plus rational           \ 2 + 3/4 \ 11/4 \
Integer plus canonical game     \ 2 + (1+*) \ 3* \
Integer minus rational          \ 2 - 3/4 \ 5/4 \
Integer minus canonical game    \ 2 - (1+*) \ 1* \

// Canonical form specification

Composition                     \ {0|^*5} \ ^^*4 \
Slashes                         \ {3|||2||1|0,*||||-1/2} \ {3|||2||1|0,*||||-1/2} \
Ambiguous slashes               \ {3|2|1} \ !!Syntax error: null \
Floating slash                  \ 1|0 \ !!Syntax error: missing EOF at '|' \
Switch                          \ +-1 \ +-1 \
Fractional switch               \ +-1/2 \ +-1/2 \
Multiple switch                 \ +-(1,1+*) \ +-(1,1*) \
Number + switch                 \ 3+-1 \ {4|2} \
Compound switch                 \ +-1+-2+-3+-4 \ +-{10|8||6|4|||4|2||0|-2} \
Tiny                            \ {0||0|-1} \ 1.Tiny \
Tiny fraction                   \ {0||0|-1/4} \ (1/4).Tiny \
Tiny G                          \ {0|||0||-1|-2} \ {2|1}.Tiny \
Miny                            \ {1|0||0} \ 1.Miny \
Pow                             \ {0|v*} \ ^.Pow(2) \
Pow*                            \ {0,*|v} \ ^.Pow(2)+* \
PowTo                           \ {^|*} \ ^.PowTo(2) \
PowTo*                          \ {0,^*|0} \ ^.PowTo(2)+* \

// Loopy game specification

on                              \ {pass|} \ on \
off                             \ {|pass} \ off \
over                            \ {0|pass} \ over \
under                           \ {pass|0} \ under \
upon                            \ {pass|*} \ {pass|*} \
upon (node reference notation)  \ a:{a|*} \ {pass|*} \
Simple ko                       \ a:{1||a|0} \ a:{1||a|0} \
Hanging pass                    \ pass \ !!Unexpected "pass". \
Hanging pass 2                  \ {1|0+pass} \ !!Unexpected "pass". \

// Simplification

Multiplier simplification       \ (*+*)*3 \ 0 \
Integer exponent simplification \ 2^(*+*) \ 1 \

// Collections

List                            \ [3,5,3,1] \ [3,5,3,1] \
Set                             \ {3,5,3,1} \ {1,3,5} \
Heterogeneous set               \ {3,"foo",nil,true,[3,5,3,1],+-6,*2,"bar"} \ {nil,true,"bar","foo",3,*2,+-6,[3,5,3,1]} \
Map                             \ {"foo" => 1, "bar" => *2, 16 => 22} \ {"bar" => *2, "foo" => 1, 16 => 22} \
Range                           \ 3..7 \ [3,4,5,6,7] \
Listof                          \ listof(x^2 for x from 1 to 5) \ [1,4,9,16,25] \
Setof                           \ setof(x^2 for x in [1,3,5,3]) \ {1,9,25} \
Empty setof                     \ setof(x) \ !!Syntax error: null \
Sumof                           \ sumof(n for n from 1 to 10) \ 55 \
Sumof 2                         \ sumof("foo" from 1 to 4) \ "foofoofoofoo" \

Tableof                         \ tableof([n,n^2] for n from 1 to 3) \
1 | 1
--+--
2 | 4
--+--
3 | 9 \

// Function calls

Optional argument out of order  \ game.grid.Clobber(anti => true, "."); \ !!Ordinary arguments must precede optional arguments in function call. \

// Procedures

Procedure definition            \ f := x -> x+1 \ <Object of type Procedure> \
Procedure evaluation            \ f(8) \ 9 \
Procedure scope 1               \ y := 3; f := x -> x+y; f(5) \ 8 \
Procedure scope 2               \ y := 6; f(5) \ 11 \
Procedure scope 3               \ x := 9; f(5); x \ 9 \
Procedure scope 4               \ f := temp -> temp+1; f(5); temp \ !!That variable is not defined: temp \
Multiparameter procedure        \ f := (x,y) -> (x+y)/2; f(3,4) \ 7/2 \
Procedure - too few args        \ f(3) \ !!Expecting 2 argument(s); found 1 \
Procedure - too many args       \ f(3,4,5) \ !!Expecting 2 argument(s); found 3 \
Procedure - optional arg        \ f(3,4,foo => 5) \ !!Invalid optional parameter: foo \
No-parameter procedure          \ f := () -> 3; f(); \ 3 \

// Do loops

Do loop: for-from-to            \ x := []; for n from 1 to 5 do x.Add(n) end; x \ [1,2,3,4,5] \
Do loop: from-to                \ listof(5 from 1 to 3) \ [5,5,5] \
Do loop: for-from-to-by         \ listof(x for x from 1 to 10 by 3) \ [1,4,7,10] \
Do loop: for-from-to-by (neg)   \ listof(x for x from 6 to 1 by -2) \ [6,4,2] \
Do loop: for-from-while         \ listof(x for x from 1 while x < 5) \ [1,2,3,4] \
Do loop: for-while-where        \ x := 1; listof(x for x while x < 10 where x % 3 == 1) \ [1,4,7] \
Do loop: to                     \ x := 5; listof(x for x to 10) \ [5,6,7,8,9,10] \
Do loop: to (illegal)           \ listof(newvar for newvar to 10) \ !!Undefined variable in for loop with no "from" clause: newvar \

// In loops

In loop: for-in                 \ x := [1,2,3,2]; y := {}; for n in x do y.Add(n); end; y \ {1,2,3} \
In loop: for-in-where           \ setof(n for n in [1,2,3,2] where n % 2 == 1) \ {1,3} \
In loop: for-in-while           \ setof(n for n in [1,2,3,2] while n % 2 == 1) \ {1} \
In loop: for-in-while-where     \ setof(n for n in [1,2,3,2] while n % 2 == 1 where n != 1) \ {} \
In loop: for-in (illegal)       \ setof(n for n in 5) \ !!Not a valid collection or iterator. \

// TODO Iterators

CollectionIterator: matches     \ a := {1,2,3}; it := cgsuite.util.iterators.CollectionIterator(a); b := {}; while it.HasNext do b.Add(it.Next); end; a == b \ true \
CollectionIterator: reset       \ a := setof(k for k from 1 to 100); it := cgsuite.util.iterators.CollectionIterator(a); for i from 1 to 10 do it.Next; end; it.Reset(); b := {}; while it.HasNext do b.Add(it.Next); end; a == b; \ true \
CollectionIterator: empty input \ a := []; it := cgsuite.util.iterators.CollectionIterator(a); it.HasNext \ false \
ChainedIterator: matches        \ a := [1,2]; b := [3]; ita := cgsuite.util.iterators.CollectionIterator(a); itb := cgsuite.util.iterators.CollectionIterator(b); it := cgsuite.util.iterators.ChainedIterator([ita,itb]); out := []; while it.HasNext do out.Add(it.Next) end out; \ [1,2,3] \
ChainedIterator: varargs        \ a := [1,2]; b := [3]; ita := cgsuite.util.iterators.CollectionIterator(a); itb := cgsuite.util.iterators.CollectionIterator(b); it := cgsuite.util.iterators.ChainedIterator(ita,itb); out := []; while it.HasNext do out.Add(it.Next) end out; \ [1,2,3] \
ChainedIterator: dup args       \ a := [1,2]; ita := cgsuite.util.iterators.CollectionIterator(a); it := cgsuite.util.iterators.ChainedIterator(ita,ita); out := []; while it.HasNext do out.Add(it.Next) end out; \ [1,2,1,2] \
ChainedIterator: mixed args     \ a := [1]; ita := cgsuite.util.iterators.CollectionIterator(a); it := cgsuite.util.iterators.ChainedIterator(ita,[ita,[ita]]); out := []; while it.HasNext do out.Add(it.Next) end out \ [1,1,1] \
ChainedIterator: empty parts    \ a := [1,2]; b := []; ita := cgsuite.util.iterators.CollectionIterator(a); itb := cgsuite.util.iterators.CollectionIterator(b); it := cgsuite.util.iterators.ChainedIterator(ita,itb,ita); out := []; while it.HasNext do out.Add(it.Next) end out \ [1,2,1,2] \
ChainedIterator: reset          \ a := listof(k for k from 1 to 100); b := listof(k for k from 1 to 50); ita := cgsuite.util.iterators.CollectionIterator(a); itb := cgsuite.util.iterators.CollectionIterator(b); it := cgsuite.util.iterators.ChainedIterator(ita,itb); for i from 1 to 50 do it.Next; end; it.Reset(); i := 0; while it.HasNext do it.Next; i := i+1; end; i \ 150 \
FilteredIterator: matches       \ a := listof(k for k from 1 to 10); it := cgsuite.util.iterators.FilteredIterator(cgsuite.util.iterators.CollectionIterator(a), x -> x % 3 == 0); out := []; while it.HasNext do out.Add(it.Next); end; out \ [3,6,9] \
FilteredIterator: multiple prop \ a := listof(k for k from 1 to 30); it := cgsuite.util.iterators.FilteredIterator(cgsuite.util.iterators.CollectionIterator(a), x -> x % 3 == 0, x -> x % 5 == 3); out := []; while it.HasNext do out.Add(it.Next); end; out \ [3,18] \
FilteredIterator: next without hasNext  \ a := listof(k for k from 1 to 30); it := cgsuite.util.iterators.FilteredIterator(cgsuite.util.iterators.CollectionIterator(a), x -> x % 3 == 0); for i from 1 to 5 do it.Next; end; out := []; while it.HasNext do out.Add(it.Next); end; out \ [18,21,24,27,30] \
FilteredIterator: reset         \ a := listof(k for k from 1 to 30); it := cgsuite.util.iterators.FilteredIterator(cgsuite.util.iterators.CollectionIterator(a), x -> x % 3 == 0); for i from 1 to 5 do it.Next; end; it.Reset(); it.Next \ 3 \
NestedIterator: matches         \ a := [1,2]; b := [10,20]; it := cgsuite.util.iterators.NestedIterator(a,b); out := []; while it.HasNext do out.Add(it.Next); end; out \ [[1,10],[1,20],[2,10],[2,20]] \
NestedIterator: mix             \ a := [1,2]; b := [10,20]; it1 := cgsuite.util.iterators.NestedIterator(a,b); it := cgsuite.util.iterators.NestedIterator([1],it1); out := []; while it.HasNext do out.Add(it.Next); end; out \ [[1,[1,10]],[1,[1,20]],[1,[2,10]],[1,[2,20]]] \
NestedIterator: reset           \ a := [1,2]; b := [1,2,3]; c := [1,2,3,4,5]; it := cgsuite.util.iterators.NestedIterator(a,b,c); for i from 1 to 15 do it.Next; end; it.Reset(); it.Next \ [1,1,1] \
SequenceIterator: matches       \ it := cgsuite.util.iterators.SequenceIterator(2,[1,2]); out := []; while it.HasNext do out.Add(it.Next); end; out \ [[1,1],[1,2],[2,1],[2,2]] \
SequenceIterator: matches       \ it := cgsuite.util.iterators.SequenceIterator(10,[0,1]); for i from 1 to 300 do it.Next; end; it.Next \ [0,1,0,0,1,0,1,1,0,0] \
SequenceIterator: empty         \ it := cgsuite.util.iterators.SequenceIterator(10,[]); it.HasNext  \ false \
SequenceIterator: empty 0       \ it := cgsuite.util.iterators.SequenceIterator([],0); it.HasNext \ true \
SequenceIterator: reset         \ it := cgsuite.util.iterators.SequenceIterator(10,[0,1]); for i from 1 to 300 do it.Next; end; it.Reset(); it.Next \ [0,0,0,0,0,0,0,0,0,0] \
PrimesIterator: because it's there  \ it := cgsuite.util.iterators.PrimesIterator(); out := []; for i from 1 to 10 do out.Add(it.Next); end; out \ [2,3,5,7,11,13,17,19,23,29] \
PrimesIterator: 1000th prime    \ it := cgsuite.util.iterators.PrimesIterator(); for i from 1 to 999 do it.Next; end; it.Next \ 7919 \
Stack: As DFS                   \ max := 11; s := cgsuite.util.iterators.Stack(); s.Push(1); out := []; while s.HasNext do val := s.Next; out.Add(val); if (2*val <= max) then s.Push(2*val); end; if (2*val+1 <= max) then s.Push(2*val+1); end; end; out \ [1,3,7,6,2,5,11,10,4,9,8] \
Queue: As BFS                   \ max := 11; s := cgsuite.util.iterators.Queue(); s.Add(1); out := []; while s.HasNext do val := s.Next; out.Add(val); if (2*val <= max) then s.Add(2*val); end; if (2*val+1 <= max) then s.Add(2*val+1); end; end; out \ [1,2,3,4,5,6,7,8,9,10,11] \

// Implicit semicolons

Implicit semicolon after if/then    \ if true then end 5 \ 5 \
Implicit semicolon after do loop    \ from 1 to 1 do end 5 \ 5 \
Implicit semicolon after in loop    \ for x in {1} do end 5 \ 5 \
Implicit semicolon after begin/end  \ begin end 5 \ 5 \

// Copy on write

Copy on write                   \ x := [1,2,3]; y := [4,x,5]; x[2] := 6; [x,y] \ [[1,6,3],[4,[1,2,3],5]] \
Complex copy on write           \ x := [1,2,3]; y := [4,x,5]; x[2] := y; y[2] := x; y \ [4,[1,[4,[1,2,3],5],3],5] \

// Classdefs

Class name != filename          \ test.classdef.TestBadClassName; \ !!Classname in file does not match filename: TestBadClassName.cgs \
Extends qualified class name    \ test.classdef.TestExtendsSubclass(); \ ok \
Imports package                 \ test.classdef.TestImports().testImportedPackage(); \ 1 \
Imports class                   \ test.classdef.TestImports().testImportedClass(); \ 1/2 \
Imports class - nonimported     \ test.classdef.TestImports().testNonImportedClass(); \ !!That variable is not defined: ToadsAndFrogs \
Duplicate var                   \ test.classdef.TestDuplicateVar; \ !!Duplicate variable: x \
No default Java constructor     \ test.classdef.TestBadConstructor; \ !!Class declares a constructor, but its underlying Java class (org.cgsuite.lang.CgsuiteInteger) does not provide a default constructor. \

// Initializers

Static initializers             \ test.classdef.TestStaticInitializers.Y \ 7 \

// Method calls

Optional parameters - defaults      \ meth := test.classdef.TestMethods(); meth.Method1(1, 2) \ [1,2,nil,nil,7,7] \
Too few required parameters         \ meth.Method1(1) \ !!Expecting at least 2 argument(s) for method call: test.classdef.TestMethods.Method1 \
Too many parameters                 \ meth.Method1(1, 2, 3, 4, 5, 6, 7) \ !!Expecting at most 6 argument(s) for method call: test.classdef.TestMethods.Method1 \
Implicit optional parameters        \ meth.Method1(1, 2, 3, 4, 5) \ [1,2,3,4,5,5] \
Optional parameters - specified 1   \ meth.Method1(1, 2, param5 => 5) \ [1,2,nil,nil,5,5] \
Optional parameters - specified 2   \ meth.Method1(1, 2, param5 => 5, param6 => 6) \ [1,2,nil,nil,5,6] \
Optional parameters - invalid       \ meth.Method1(1, 2, noGood => 5) \ !!Not a valid optional parameter: noGood (in call to method test.classdef.TestMethods.Method1) \
Optional parameters - duplicate     \ meth.Method1(1, 2, 3, 4, 5, param5 => 5) \ !!Duplicate parameter: param5 (in call to method test.classdef.TestMethods.Method1) \
Validation failure                  \ meth.Method1("znear", "diablo") \ !!Invalid arguments in call to test.classdef.TestMethods.Method1: parameter "param2" must be of class cgsuite.lang.Integer. \
Optional parameters - validation    \ meth.Method1(1, 2, param3 => "znear", param4 => "diablo") \ !!Invalid arguments in call to test.classdef.TestMethods.Method1: parameter "param4" must be of class cgsuite.lang.Integer. \
Default copy validation failure     \ meth.Method1(1, 2, param5 => "znear") \ !!Invalid arguments in call to test.classdef.TestMethods.Method1: parameter "param6" must be of class cgsuite.lang.Integer. \
Vararg - too few parameters         \ meth.MethodWithVararg(1) \ !!Expecting at least 2 argument(s) for method call: test.classdef.TestMethods.MethodWithVararg \
Vararg - required only              \ meth.MethodWithVararg(1, 2) \ [1,2,[]] \
Vararg - single vararg              \ meth.MethodWithVararg(1, 2, 3) \ [1,2,[3]] \
Vararg - multi vararg               \ meth.MethodWithVararg(1, 2, 3, 4, 5, 6, 7) \ [1,2,[3,4,5,6,7]] \
Vararg - typed                      \ meth.TypedMethodWithVararg(1, 2, 3, 4, 5, 6, 7) \ [1,2,[3,4,5,6,7]] \
Vararg - typed validation failure   \ meth.TypedMethodWithVararg(1, 2, 3, 4, 5, "znear", 7) \ !!Invalid arguments in call to test.classdef.TestMethods.TypedMethodWithVararg: parameter "param3" must be of class cgsuite.lang.Integer. \
Vararg - with option                \ meth.MethodWithVarargAndOption(1, 2, 3, 4, 5, 6, 7) \ [1,2,[3,4,5,6,7],nil,9] \
Vararg - with option specified      \ meth.MethodWithVarargAndOption(1, 2, 3, 4, 5, 6, 7, param4 => 8) \ [1,2,[3,4,5,6,7],8,9] \

// Control statements

Unexpected break                \ break; \ !!Unexpected control statement: break \
Unexpected continue             \ continue; \ !!Unexpected control statement: continue \
Unexpected return               \ return 5; \ !!Unexpected control statement: return \
Unexpected break in procedure   \ f := x -> (break); f(0) \ !!Unexpected control statement in procedure: break \
Unexpected continue in procedure\ f := x -> (continue); f(0) \ !!Unexpected control statement in procedure: continue \
Unexpected return in procedure  \ f := x -> (return); f(0) \ !!Unexpected control statement in procedure: return \
Unexpected break in method      \ test.lang.TestControlStatements.UnexpectedBreak(); \ !!Unexpected control statement in method: break \
Unexpected continue in method   \ test.lang.TestControlStatements.UnexpectedContinue(); \ !!Unexpected control statement in method: continue \
Return from loop                \ test.lang.TestControlStatements.ReturnFromLoop(); \ 101 \

// Procedures in classes

Static procedure                \ test.lang.TestProcedureScope.StaticProcedure() \ 6 \
// TODO procedures with method scope

// Immutability

Immutable retrieval                     \ mut := test.mutability.TestImmutable(); mut.Retrieve(3); \ 3 \
Immutable assignment                    \ mut := test.mutability.TestImmutable(); mut.AssignBad([5,6,7]); \ !!Cannot change member variable of immutable object: x \
Immutable member mutation               \ mut := test.mutability.TestImmutable(); mut.MutateBad(3, 9); \ !!Cannot call mutable method on member of immutable object: cgsuite.lang.List.op []:= \
Mutable retrieval                       \ mut := test.mutability.TestMutable(); mut.Retrieve(3); \ 3 \
Mutable assignment                      \ mut := test.mutability.TestMutable(); mut.AssignGood([5,6,7]); mut.Retrieve(3); \ 7 \
Mutable member mutation                 \ mut := test.mutability.TestMutable(); mut.MutateExplicit(3, 9); mut.Retrieve(3); \ 9 \
Immutable method - assignment           \ mut := test.mutability.TestMutable(); mut.AssignBad([5,6,7]); \ !!Cannot assign to member variable from inside an immutable method: x \
Immutable object - call explicit mutable\ mut := test.mutability.TestImmutable(); mut.CallMutateExplicit(3, 9); \ !!Cannot call mutable method on member of immutable object: test.mutability.TestMutable.MutateExplicit \
Immutable object - call implicit mutable\ mut := test.mutability.TestImmutable(); mut.CallMutateImplicit(3, 9); \ !!Cannot call mutable method on member of immutable object: cgsuite.lang.List.op []:= \
Immutable declares mutable              \ test.mutability.TestBadImmutable; \ !!Declaration is marked "mutable" but enclosing class is not: NoGood \
Immutable inherits mutable              \ test.mutability.TestBadImmutableInheritance; \ !!Class is not marked "mutable", but has a mutable parent: test.mutability.TestMutable \
Static mutable                          \ test.mutability.TestBadStaticMutable; \ !!Static method cannot be marked "mutable": StaticMutable \

// Var shadowing

Do loop variable shadows member var     \ shadow := test.lang.TestShadowing(); shadow.ShadowDoLoop(); \ !!Loop variable name shadows member variable: x \
Do loop variable shadows super var      \ shadow := test.lang.TestShadowingSubclass(); shadow.SubShadowDoLoop(); \ !!Loop variable name shadows member variable: x \
Do loop variable shadows subclass var   \ shadow := test.lang.TestShadowingSubclass(); shadow.NonShadowDoLoop(); \ "ok" \
In loop variable shadows member var     \ shadow := test.lang.TestShadowing(); shadow.ShadowInLoop(); \ !!Loop variable name shadows member variable: x \
In loop variable shadows super var      \ shadow := test.lang.TestShadowingSubclass(); shadow.SubShadowInLoop(); \ !!Loop variable name shadows member variable: x \
In loop variable shadows subclass var   \ shadow := test.lang.TestShadowingSubclass(); shadow.NonShadowInLoop(); \ "ok" \
Local variable shadows subclass var     \ shadow := test.lang.TestShadowingSubclass(); shadow.NonShadowLocalSub(); \ 5 \
Method parameter shadows subclass var   \ shadow := test.lang.TestShadowingSubclass(); shadow.NonShadowParamSub(); \ 5 \
Member var shadows superclass var       \ test.lang.TestBadShadow; \ !!Variable shadows superclass var: x (from class test.lang.TestShadowing) \
Var assigned by constructor delegate 1  \ shadow := test.lang.TestConstructorDelegate(); shadow.Value \ 5 \
Var assigned by constructor delegate 2  \ shadow := test.lang.TestConstructorDelegate(); shadow.ThisValue \ 5 \

// cgsuite.lang.Integer

NimSum                          \ 3.NimSum(5) \ 6 \
NimProduct                      \ 8.NimProduct(8) \ 13 \
Div                             \ 17.Div(4) \ 4 \
Is2Power                        \ [32.Is2Power,48.Is2Power] \ [true,false] \
IsSmall                         \ [2^31,-2^31,2^31-1,-2^31-1].Apply(x -> x.IsSmall) \ [false,true,true,false] \
Lb                              \ [15,16,17,31,2^31-1,2^31].Apply(x -> x.Lb) \ [3,4,4,4,30,31] \
Random                          \ Integer.SetSeed(0); listof(Integer.Random(100) from 1 to 5) \ [61,49,30,48,16] \
Isqrt                           \
    for n from 0 to 3000 do
        isqrt := n.Isqrt;
        if n < isqrt^2 or n >= (isqrt+1)^2 then
            error("Isqrt failed at " + n.ToString);
        end
    end \ nil \

// cgsuite.lang.Class

Name                            \ Object.Name \ "Object" \

// cgsuite.lang.Collection

IsEmpty                         \ [0,1,3,4].IsEmpty \ false \
Mex                             \ [0,1,3,4].Mex \ 2 \
ToList                          \ list := {5,1,3}.ToList; list.Sort(); list \ [1,3,5] \
ToSet                           \ [5,1,3].ToSet \ {1,3,5} \

// cgsuite.lang.Enum

Ordinal                         \ Player.Left.Ordinal \ 1 \
Literal                         \ Player.Left.Literal \ "Left" \

// cgsuite.lang.List

List - create                           \ list := ["znear","el","diablo"]; \ ["znear","el","diablo"] \
List - lookup                           \ list[3] \ "diablo" \
list - assign                           \ list[2] := "the" \ "the" \
List - check result                     \ list \ ["znear","the","diablo"] \
List.Add                                \ list.Add("foo"); \ nil \
List.AddAll                             \ list.AddAll(["x","y"]) \ nil \
List.Remove                             \ list.Remove("the"); \ true \
List.InsertAt                           \ list.InsertAt(1, "bar"); \ nil \
List.RemoveAt                           \ list.RemoveAt(2); \ "znear" \
List - check result                     \ list \ ["bar","diablo","foo","x","y"] \
List.SubList                            \ list.SubList(2,3) \ ["diablo","foo"] \
List.Length                             \ list.Length \ 5 \
List.Size                               \ list.Size \ 5 \
List.Contains                           \ list.Contains("diablo") \ true \
List.Clear                              \ list.Clear(); \ nil \
List - check result again               \ list \ [] \
List.Sort (custom comparator)           \ list := [1,7,2,5,4]; list.Sort((x,y) -> y-x); list \ [7,5,4,2,1] \
List.Sort (default comparator)          \ list.Sort(); list \ [1,2,4,5,7] \
List.PeriodicTable                      \ list.PeriodicTable(3) \
1 | 2 | 4
--+---+--
5 | 7 |    \
List.ToString                           \ list.ToString \ "[1,2,4,5,7]" \
List.Apply                              \ [1,3,6].Apply(x -> x^2) \ [1,9,36] \
List.Filter                             \ [1,3,6].Filter(x -> x%2 == 0) \ [6] \
List.AnyElement                         \ [1,3,6].AnyElement \ 1 \
List.RandomElement                      \ Integer.SetSeed(0); [1,3,6].RandomElement \ 1 \
List - lookup negative                  \ list[-1] \ !!Invalid list index: -1 \
List - lookup large                     \ list[10] \ nil \
List - assign negative                  \ list[0] := 5 \ !!Invalid list index: 0 \
List - assign large                     \ list[10] := 5; list \ [1,2,4,5,7,nil,nil,nil,nil,5] \
List - InsertAt negative                \ list.InsertAt(0, 8) \ !!Invalid list index: 0 \
List - InsertAt large                   \ list.InsertAt(13, 0); list \ [1,2,4,5,7,nil,nil,nil,nil,5,nil,nil,0] \
List - RemoveAt negative                \ list.RemoveAt(-1) \ !!Invalid list index: -1 \
List - RemoveAt large                   \ list.RemoveAt(22) \ nil \
List - check result                     \ list \ [1,2,4,5,7,nil,nil,nil,nil,5,nil,nil,0] \
List - immutable subreferences          \ mut := test.mutability.TestImmutableSubreferences([[1]]); mut.TestImmutableList(); \ !!Cannot call mutable method on member of immutable object: cgsuite.lang.List.op []:= \
List - crosslinked subreferences        \ mut.TestCrosslinkedList(); \ nil \

// cgsuite.lang.Map

Map - create                            \ map := {"foo" => "bar", "znear" => "diablo"}; \ {"foo" => "bar", "znear" => "diablo"} \
Map - retrieve                          \ map["znear"] \ "diablo" \
Map - retrieve (not key)                \ map[0] \ nil \
Map - assign existing                   \ map["foo"] := 17; map \ {"foo" => 17, "znear" => "diablo"} \
Map - assign new                        \ map["bar"] := 73; map \ {"bar" => 73, "foo" => 17, "znear" => "diablo"} \
Map.Size                                \ map.Size \ 3 \
Map.Keys                                \ map.Keys \ {"bar","foo","znear"} \
Map.Clear                               \ map.Clear(); map \ {=>} \
Map - immutable subreferences           \ mut := test.mutability.TestImmutableSubreferences({"znear"=>[1,2,3]}); mut.TestImmutableMap(); \ !!Cannot call mutable method on member of immutable object: cgsuite.lang.List.op []:= \
Map - crosslinked subreferences         \ mut.TestCrosslinkedMap(); \ nil \

// cgsuite.lang.Number

Number.Min                              \ 22.Min(43/2) \ 43/2 \
Number.Max                              \ (27/2).Max(13) \ 27/2 \
Number.Abs                              \ [(-1).Abs,0.Abs,1.Abs] \ [1,0,1] \
Number.Ceiling                          \ (27/16).Ceiling \ 2 \
Number.Floor                            \ (27/16).Floor \ 1 \
Number.IsInfinite                       \ [-inf,0,inf].Apply(x -> x.IsInfinite) \ [true,false,true] \
Number.IsDyadic                         \ [1,1/2,1/3,1/4,1/5].Apply(x -> x.IsDyadic) \ [true,true,false,true,false] \

// cgsuite.lang.Object

Object.Class                            \ *5.Class \ Nimber \

// cgsuite.lang.Procedure

Procedure.ParameterCount                \ ((x,y) -> x+y).ParameterCount \ 2 \
Procedure.op*                           \ f := x -> x^2; g := x -> x+1; [(f*g)(5),(g*f)(5)] \ [36,26] \
Procedure.op^                           \ f := x -> x*2; listof((f^n)(1) for n from 0 to 5) \ [1,2,4,8,16,32] \
Define 3n+1 procedure                   \ threen := n -> if n%2 == 0 then n/2 else 3*n+1 end \ <Object of type Procedure> \
Procedure.Iterate                       \ threen.Iterate(10)(27) \ [82,41,124,62,31,94,47,142,71,214] \
Procedure.IterateUntil                  \ threen.IterateUntil(x -> x == 1)(27).Length \ 111 \

// cgsuite.lang.Set

Set - construction                      \ s := {6,1,3} \ {1,3,6} \
Set.Add                                 \ s.Add(2) \ nil \
Set.Add (existing)                      \ s.Add(2) \ nil \
Set.AddAll                              \ s.AddAll([5,1,8,5]) \ nil \
Set - check result                      \ s \ {1,2,3,5,6,8} \
Set.Contains                            \ [s.Contains(5), s.Contains(4)] \ [true,false] \
Set.Remove                              \ s.Remove(5) \ true \
Set.Remove (not in set)                 \ s.Remove(5) \ false \
Set.RemoveAll                           \ s.RemoveAll({1,4,8}) \ true \
Set - check result                      \ s \ {2,3,6} \
Set.AnyElement                          \ x := s.AnyElement; x == 2 or x == 3 or x == 6 \ true \
Set.RandomElement                       \ x := s.RandomElement; x == 2 or x == 3 or x == 6 \ true \
Set.Apply                               \ s.Apply(n -> n^2) \ {4,9,36} \
Set.FilterWith                          \ s.FilterWith(n -> n%2 == 0) \ {2,6} \
Set.Clear                               \ s.Clear(); \ nil \
Set - check result                      \ s \ {} \
Set - immutable subreferences           \ mut := test.mutability.TestImmutableSubreferences({[1]}); mut.TestImmutableSet(); \ !!Cannot call mutable method on member of immutable object: cgsuite.lang.List.op []:= \
Set - crosslinked subreferences         \ mut.TestCrosslinkedSet(); \ nil \

// cgsuite.lang.String

String - construction                   \ str := "foo" \ "foo" \
String - append                         \ str + "bar" \ "foobar" \
String.Length                           \ str.Length \ 3 \

// cgsuite.util.Grid

Grid - construction             \ Grid(2,3) \ "...|..." \
Grid.ParseGrid                  \ grid := Grid.ParseGrid("xox.|.ox.", ".xo") \ "121.|.21." \
Grid.RowCount                   \ grid.RowCount \ 2 \
Grid.ColumnCount                \ grid.ColumnCount \ 4 \
Grid.op[]                       \ grid[2,3] \ 1 \
Grid.op[]:=                     \ grid[2,3] := 2; grid \ "121.|.22." \
Grid.SubGrid                    \ grid.SubGrid(1,2,2,4) \ "21.|22." \
Grid.Decompose                  \ grid.Decompose(2) \ ["1|.","1.|2."] \
Grid.LibertyCount               \ grid.LibertyCount(1,2,0) \ 2 \
Grid.Contains                   \ listof(grid.Contains(n) for n from 0 to 4) \ [true,true,true,false,false] \
Grid.Paste                      \ grid.Paste(Grid(2,2), 2, 2); \ nil \
Grid - checkback                \ grid \ "121.|...." \
Grid.Clear                      \ grid.Clear() \ nil \
Grid - checkback                \ grid \ "....|...." \
Grid.Permute                    \ grid := Grid.ParseGrid("123|456|789", ".123456789");
                                  setof(grid.Permute(sym) for sym in Symmetry.Reflection)
                                \ {"123|456|789","321|654|987","789|456|123","987|654|321"} \
Grid (invalid char violation)   \ Grid.ParseGrid("xox.|.oxj", ".xo") \ !!The position may only contain the following characters: .xo \
Grid (equal length violation)   \ Grid.ParseGrid("xox.|.ox", ".xo") \ !!All rows of the position must have equal length. \

// cgsuite.util.Strip

Strip - construction            \ Strip(5) \ "....." \
Strip.ParseStrip                \ strip := Strip.ParseStrip("xo..x", ".xo") \ "12..1" \
Strip.op[]                      \ strip[2] \ 2 \
Strip.op[]:=                    \ strip[3] := 1; strip \ "121.1" \
Strip.SubStrip                  \ strip.SubStrip(2,4) \ "21." \
Strip.Paste                     \ strip.Paste(Strip(4), 3) \ nil \
Strip - checkback               \ strip \ "12..." \
Strip.LibertyCount              \ strip.LibertyCount(2, 0) \ 1 \
Strip (multirow violation)      \ Strip.ParseStrip("xox|.ox", ".xo") \ !!The position must contain just one row. \

// cgsuite.util.Table

Table - immutable subreferences         \ tab := tableof([1] from 1 to 1); mut := test.mutability.TestImmutableSubreferences(tab); mut.TestImmutableTable(); \ !!Cannot call mutable method on member of immutable object: cgsuite.lang.List.op []:= \
Table - crosslinked subreferences       \ mut.TestCrosslinkedTable(); \ nil \

// CanonicalShortGame

Game relations (0,*)            \ [*==0, *>=0, *<=0, *>0, *<0, *<>0, *|>0, *<|0, *!=0, *<=>0] \ [false,false,false,false,false,true,true,true,true,*] \
Game relations (0,1)            \ [1==0, 1>=0, 1<=0, 1>0, 1<0, 1<>0, 1|>0, 1<|0, 1!=0, 1<=>0] \ [false,true,false,true,false,false,true,false,true,1] \
Simplification                  \ 1-1==0 \ true \
AtomicWeight                    \ {^^*|*,v}.AtomicWeight \ 1/2 \
AtomicWeight (not infinitesimal)\ 1.AtomicWeight \ !!That game is not atomic. \
AtomicWeight (not atomic)       \ {2|^^||0}.AtomicWeight \ !!That game is not atomic. \
AtomicWeight (not all small)    \ {1|^||0}.AtomicWeight \ 1 \
Birthday                        \ ^^*2.Birthday \ 4 \
Birthday2                       \ (117/64).Birthday \ 8 \
Companion                       \ {1|^^}.Companion \ {1|^^*} \
Diversity                       \ *10.Diversity \ 11 \
Freeze                          \ {3+*||2|1}.Freeze \ 9/4* \
// Incentives                   \ TODO \ \
// Is*                          \ TODO \ \
IsUptimal                       \ {0||0|vvv}.IsUptimal \ false \
LeftOptions                     \ {*2,*|-1}.LeftOptions \ {*,*2} \
LeftStop                        \ {*2,*|-1}.LeftStop \ 0 \
Mean                            \ {3+*||2|1}.Mean \ 9/4 \
Miny                            \ 3+2.Miny \ 3+2.Miny \
Rcf                             \ {3+*||2|1}.Rcf \ {3||2|1} \
RightOptions                    \ {*2,*|-1}.RightOptions \ {-1} \
RightStop                       \ {*2,*|-1}.RightStop \ -1 \
StopCount                       \ *10.StopCount \ 39366 \
Temperature                     \ {3+*||2|1}.Temperature \ 3/4 \
// Thermograph                  \ TODO \ \
Tiny                            \ 2.Tiny \ 2.Tiny \
Heat                            \ *2.Heat(1) \ +-(1,{2|0}) \
Overheat                        \ (31/64).Overheat(0,0) \ ^.PowTo(5) \
Cool                            \ {3+*||2|1}.Cool(1/2) \ {5/2|2*} \
Cool2                           \ {3+*||2|1}.Cool(1) \ 9/4 \
NortonProduct                   \ ^.NortonProduct(^) \ {^^*||0|v4} \
ConwayProduct                   \ *14.ConwayProduct(*19) \ *233 \
OrdinalSum                      \ *4.OrdinalSum(*5) \ *9 \
Pow                             \ ^^.Pow(3) \ ^.Pow(3) \
PowTo                           \ ^^.PowTo(3) \ {^^|^*||^*} \
Options                         \ {*2,*|-1}.Options(Player.Left) \ {*,*2} \

// DayN

Count of day-3 games            \ DayN(3).Size \ 1474 \
Count of day-3 all-small games  \ DayN(3, allSmall => true).Size \ 67 \
Count of day-3 reduced games    \ DayN(3, reduced => true).Size \ 61 \
Count of day-2 antichains       \ DayN(2).Antichains.Size \ 98 \

// ExplicitGame

ExplicitGame construction       \ g := { -100, game.grid.Clobber("xo|ox")|0} \ {-100,Clobber("xo|ox")|0} \
ExplicitGame options            \ g.LeftOptions \ {-100,Clobber("xo|ox")} \
ExplicitGame canonical form     \ g.CanonicalForm \ v \

// Game

Default addition                \ test.Nim(6) + test.Nim(5) \ Nim(6) + Nim(5) \
Default subtraction             \ test.Nim(6) - test.Nim(5) \ Nim(6) + -Nim(5) \
Default negation                \ -test.Nim(5) \ -Nim(5) \
Sensible options                \ test.PartizanSubtraction({1,3},{2,3},11).SensibleRightOptions \ {PartizanSubtraction({1,3},{2,3},9)} \
Sensible lines                  \ test.PartizanSubtraction({1,3},{2,3},3).SensibleLeftLines \ {[PartizanSubtraction({1,3},{2,3},0)],[PartizanSubtraction({1,3},{2,3},2)]} \
// TODO RandomPlay, RandomWinner
// TODO CanonicalShortGame surrogates?

// GridGame

GridGame.Grid                   \ game.grid.Amazons("x..|o..").Grid \ "1..|2.." \

// ImpartialGame

ImpartialGame.NimValue          \ game.heap.Heap("0.123", 8).NimValue \ 2 \
ImpartialGame.MisereNimValue    \ game.heap.Heap("0.123", 8).MisereNimValue \ 1 \

// InverseGame

InverseGame.Underlying          \ (-test.Nim(5)).Underlying \ Nim(5) \
InverseGame.op neg              \ -(-test.Nim(5)) \ Nim(5) \
InverseGame.Options             \ (-test.Nim(3)).LeftOptions \ {-Nim(0),-Nim(1),-Nim(2)} \
InverseGame.CanonicalForm       \ (-test.Nim(5)).CanonicalForm \ *5 \

// MultipleGame

MultipleGame construction       \ g := 3 * test.Nim(2) \ 3 * Nim(2) \
MultipleGame.Multiplier         \ g.Multiplier \ 3 \
MultipleGame.Multiplicand       \ g.Multiplicand \ Nim(2) \
MultipleGame.CanonicalForm      \ g.CanonicalForm \ *2 \
MultipleGame.Options            \ g.LeftOptions \ {2 * Nim(2) + Nim(0),2 * Nim(2) + Nim(1)} \
MultipleGame invalid multiplier \ (1/2) * test.Nim(2) \ !!No rules for converting org.cgsuite.lang.Game to org.cgsuite.lang.game.RationalNumber. \

// Player

Player.Opponent 1               \ Player.Left.Opponent \ Right \
Player.Opponent 2               \ Player.Right.Opponent \ Left \

// SumGame

SumGame construction            \ g := test.Nim(3) + test.Nim(2) \ Nim(3) + Nim(2) \
SumGame.op +                    \ g + test.Nim(5) \ Nim(3) + Nim(2) + Nim(5) \
SumGame.op + double-check       \ (g + test.Nim(5)).Components.Size \ 3 \
SumGame.op + RHS                \ test.Nim(5) + g \ Nim(5) + Nim(3) + Nim(2) \
SumGame.op + RHS double-check   \ (test.Nim(5) + g).Components.Size \ 3 \
SumGame.op neg                  \ -(test.Nim(3) + test.Nim(2)) \ -Nim(3) + -Nim(2) \
SumGame.Options                 \ g.LeftOptions \ {Nim(0) + Nim(2),Nim(1) + Nim(2),Nim(2) + Nim(2),Nim(3) + Nim(0),Nim(3) + Nim(1)} \
SumGame.CanonicalForm           \ g.CanonicalForm \ * \
SumGame.Components              \ g.Components \ [Nim(3),Nim(2)] \

// game.grid package

Amazons                         \ game.grid.Amazons("x...|o...").CanonicalForm \ +-(3,{4|0,{1|0,*}},{4|+-1,{0,{1/2|0}|v},+-(1,{2|0})}) \
Clobber                         \ game.grid.Clobber("xox|ox.").CanonicalForm \ {^^*|*,v} \
Clobber (Diagonal)              \ game.grid.Clobber("xoxo|oox.|xxx.", directions => Direction.Diagonal).CanonicalForm \ {0,v*|vv} \
Clobber (Anti)                  \ game.grid.Clobber("xoxo|oo..", anti => true).CanonicalForm \ {*|-1} \
Domineering                     \ game.grid.Domineering(Grid(4,4)).CanonicalForm \ +-(0,{{2|0},2+2.Tiny|{2|0},2.Miny}) \
Konane                          \ game.grid.Konane(".xo.o.o.|.o......|.x......").CanonicalForm \ {1,1*,{1,1*|0}|0} \
NoGo                            \ game.grid.NoGo("x..|...|x.x").CanonicalForm \ {3||2|1|||{1|0},{1,{2|1}|{1|0},1.Miny}} \
BicolourFission                 \ game.grid.BicolourFission("....|.x.x|.oo.|....").CanonicalForm \ {-1,+-1|-2} \ 
CrossPurposes                   \ game.grid.CrossPurposes("....|..x.|.x..").CanonicalForm \ {0|-1} \
RookRace                        \ game.grid.RookRace(".....|..#..|..x..|..o..|.....").CanonicalForm \ -1/4 \
RookRace, short moves           \ game.grid.RookRace(".....|..#..|..x..|..o.#|.....", shortMoves => true).CanonicalForm \ {1/2|0} \
Rooks                           \ game.grid.Rooks("xoxo|oxox").CanonicalForm \ +-(0,{^^*|0,+-(0,{^^*|0,+-(*,^)})},{0||^^*|0|||0,+-(*,^)}) \

// game.sowing package

BasicMancala                    \ game.sowing.BasicMancala([1,8],[2,1]).CanonicalForm \ -1/16 \
Sowing                          \ game.sowing.Sowing([2,2,2,2,2,2]).CanonicalForm \ +-{1|||1,{1|7/8}|{1|-1*},{*,{1|0,*},{1|v*}|0,{0|-1}}||0|-1} \

// game.strip package

Push                            \ game.strip.Push("xo.xo.xo.xo").CanonicalForm \ -183/32 \
ToadsAndFrogs                   \ game.strip.ToadsAndFrogs("ttttt..fffff").CanonicalForm \ +-({2|*},{5/2||2|{0||||{0||v.Pow(2)|-1},{0||||0||(1/32).Miny|-2|||-1/2*}|||v.Pow(2)|-1/2||-1*}|||0}) \
ToadsAndFrogs (strip violation) \ game.strip.ToadsAndFrogs("t.f|f.t") \ !!The position must contain just one row. \
TopplingDominoes                \ game.strip.TopplingDominoes("xoxeoxeeo").CanonicalForm \ {1/2,{1/2|*},{1/2|0,*2}|-1,{0|-1},{*,*2|-1}} \