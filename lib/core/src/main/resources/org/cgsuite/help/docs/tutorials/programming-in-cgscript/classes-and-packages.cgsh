Classes and Packages

This section describes the structure and content of a CGScript class, for example, a ruleset implementation.

+++ The Structure of a Class +++

Every class in CGSuite is associated with a $.cgs$ file.  The class declaration begins with a line such as

$class PartizanSubtraction(leftSet as Collection, rightSet as Collection) extends Ruleset$

or

$singleton class Clobber extends game.grid.GridRuleset$

The declaration specifies several things:
\ul
\li The ~~name~~ of the class (`PartizanSubtraction` or `Clobber`);
\li The ~~parent~~ class or classes (`Ruleset` in the first example; the more specific class `game.grid.GridRuleset` in the second);
\li The ~~class parameters~~ (`leftSet` and `rightSet`; the `Clobber` class doesn't have any);
\li Optional ~~modifiers~~ (`Clobber` has the modifier `singleton`, indicating that it has no parameters and only one instance).
\endul

Every class belongs to a ~~package~~, which is defined by the directory where the $.cgs$ file resides.  If the $.cgs$
file is given by, say,

$game/grid/GridRuleset.cgs$

(relative to either the User Folder or the System Folder), then the package will be $game.grid$, so the
~~qualified name~~ of the class will be $game.grid.GridRuleset$. This is why all of the examples in the `examples` folder
are contained in the examples package, such as `examples.Clobber`.

Three packages in CGSuite are special: $cgsuite.lang$, $cgsuite.util$, and $game$. These packages contain the essential
building blocks of CGScript, and references to their classes don't need to be qualified: you can type simply $Integer$ instead of
$cgsuite.lang.Integer$. Classes from any other package, such as $game.grid$ or `examples`, need to be qualified.

+++ Declarations +++

The remainder of the class is a sequence of declarations: variables, methods, and initializers.

A variable declaration has the form

`var myVar := *2;`

This establishes $myVar$ as a member variable with the value `*2`. By convention, variables and packages start with
lowercase letters, and classes and methods are capitalized. You can also omit the assignment:

`var myVar;`

This gives `myVar` the initial value `Nothing`, and is exactly equivalent to:

`var myVar := Nothing;`

Typically you'd declare `myVar` this way with the intent to assign it a value later on; however, see the below section
on Mutable and Immutable Variables.

A method declaration has the form

`def MyMethod(x, y, z) := x * y + z;`

or (equivalently, and more convenient for complicated methods)

`def MyMethod(x, y, z) begin
  x * y + z
end`

With `MyMethod` defined as above, CGSuite will admit ~any~ object for the parameters `x`, `y`, and `z`. Sometimes this
isn't what we want: for example, maybe we only ~intended~ for `MyMethod` to admit numbers; but if one calls (say)

`MyMethod(*2, *4, *8)`

CGSuite blithely accepts the input, generating an error only later, when the multiplication `x * y` is evaluated.
This can be prevented by specifying types for the parameters:

`def MyMethod(x as Rational, y as Rational, z as Rational) := x * y + z;`

This will cause CGSuite to generate an error as soon as something other than a `Rational` is passed to `MyMethod`.

+++ Inheritance +++

Every class inherits from one or more ~~parent classes~~ as defined by its $extends$ clause.  A special class, $Object$,
is automatically an ancestor of every class.  The $extends$ clause is optional, and the declaration

$class MyClass()$

without an $extends$ clause is equivalent to

$class MyClass() extends Object$

A class can ~override~ methods and properties from its ancestors.  This is done through the $override$ keyword:

$override method MyMethod(parameters)$

This specifies that $MyMethod$ is also declared by one or more ancestors, and we are redefining it in the subclass.
If a method has the same name as a method in some ancestor class, then the $override$ keyword ~must~ be specified.

+++ Static Declarations +++

Some variables and methods are `static`.  Whereas ordinary variables are members of class instances,
static variables are members of the class itself - so they exist just once, and are accessible ~statically~, without
having to create any objects of the class.

Static variables can be declared with the static keyword:

$static var myStaticVar;$

Likewise static methods:

$static method MyStaticMethod(parameters)$

You can access static methods by calling the class directly, for example,

$MyClass.MyStaticMethod$

A typical example is the $Worksheet.Print$ method, which is a static method of class $Worksheet$.

++ Enums ++

Certain classes come equipped with a fixed set of instances.  For example, the $Player$ class has just two instances,
$Player.Left$ and $Player.Right$; and $OutcomeClass$ has instances $OutcomeClass.P$, $OutcomeClass.N$, etc.

Such classes are known as ~enumerated types~, or enums, and they're treated specially in CGScript.  An enum can be
declared like so:

$enum OutcomeClass

    P,
    N,
    L,
    R;

end$

This declares an enum with exactly four instances; no others can ever be constructed.  $OutcomeClass$ is a particularly
simple example; more complex enums have methods and properties of their own (for an example, see the
$Player$ enum in $cgsuite.game$).

++ Imports ++

Sometimes you'll need to refer to a class that's not in one of the automatic import packages.  In such cases you'll need
to use an $import$ statement to make that class visible inside your $.cgs$ file.  If you put (say)

$import game.grid.Clobber;$

at the top of your .cgs file, ~before~ the class or enum declaration, then throughout the rest of the file you can
refer directly to $Clobber$.  You can also type

$import game.grid.*;$

to import ~all~ the classes in the $game.grid$ package.

This is the only way to access external classes from within a class file - you can't type $game.grid.Clobber$ directly
as you can from the worksheet.

\footer

~~Continue on to the next part of the tutorial: [[control-flow-and-scope]]~~
