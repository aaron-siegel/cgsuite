/*${cgsuite.banner}*/

class ImpartialRuleset of `T extends Ruleset of `T

  override def Eval(arg as `T) as ImpartialGame := ImpartialPosition(arg);

  override def Options(arg as `T, player as Player) as Collection of `T := Options(arg);

  override def ComponentwiseOptions(arg as `T, player as Player) as Collection of List of `T := ComponentwiseOptions(arg);

  def Options(arg as `T) as Collection of `T := error("Subclasses of `ImpartialRuleset` must override `Options`.");

  def ComponentwiseOptions(arg as `T) as Collection of List of `T := Nothing;

  override def Substitution(arg as `T) as ImpartialGame := Nothing;

  class ImpartialPosition(arg as `T) extends ImpartialGame

    override def Decomposition :=
      listof(ImpartialPosition(subArg) for subArg in EnclosingObject.Decomposition(arg));

    override def Substitution as ImpartialGame begin
      var substitution := EnclosingObject.Substitution(arg);
      if substitution != Nothing then
        substitution
      else
        this
      end
    end

    override def DepthHint := EnclosingObject.DepthHint(arg);

    override def Options as Collection of ImpartialGame begin
      var cwo := EnclosingObject.ComponentwiseOptions(arg);
      if cwo != Nothing then
        listof(sumof(ImpartialPosition(component) for component in option) for option in cwo);
      else
        listof(ImpartialPosition(option) for option in EnclosingObject.Options(arg))
      end
    end

    override def ToOutput := MakeOutput(arg);

  end

end
