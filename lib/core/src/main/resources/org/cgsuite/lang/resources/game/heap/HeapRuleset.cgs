/*${cgsuite.banner}*/

/** Base class for rulesets played on heaps of tokens.
  *
  * A position in a heap ruleset is represented by a single integer $n$, the ~heap size~.
  * From a position $H(n)$, a typical legal move is to a disjunctive sum of heaps
  *
  * $H(a_1_) + H(a_2_) + \&ctdot; + H(a_k_)$.
  *
  * Some rulesets (such as ordinary [[TakeAndBreak][take-and-break]] rulesets) require that
  * $a_1_ + a_2_ + \&ctdot; + a_k_ \&le; n$, but in the general case, there are no such
  * restrictions.
  *
  * Subclasses of `HeapRuleset` must implement [[#HeapOptions]], which takes as input a nonnegative
  * [[Integer]] (the heap size) and returns a [[Collection]] of `Collection`s of nonnegative `Integer`s.
  * Each element `L` of the outer `Collection` represents one option from `heapSize`, and each
  * element of `L` is the heap size of one summand of that option. For example,
  * Grundy's Game (split a heap into two unequal heaps) might be implemented by:
  *
  * `override def HeapOptions(n as Integer) :=` \\
  * `\sp[\[k, n-k] for k from 1 to n-1 where k != n-k];`
  *
  * In practice, it is usually easiest to use a built-in class, such as [[TakeAndBreak]] or
  * [[FunctionalHeapRuleset]], rather than creating a new subclass of `HeapRuleset`. For example,
  * Grundy's Game can also be specified simply as:
  *
  * `game.heap.TakeAndBreak("4!.0")`
  */
system class HeapRuleset extends Ruleset

  /** The acrostic product of this ruleset and `that`.
    *
    * `R.AcrosticProduct(S)` is a [[CoordinateRuleset]] whose structure is defined as follows.
    * From a position `(m,n)`, it is legal to move on `m` as if it were an element of `R`, ~or~ on `n`
    * as if it were an element of `S`. That is, for each $[a_1_,a_2_,\&hellip;a_k_]$ in `R.HeapOptions(m)`,
    * there is a move from `(m,n)` to $(a_1_,n) + (a_2_,n) + \&ctdot; + (a_k_,n)$; and for each
    * $[b_1_,b_2_,\&hellip;b_l_]$ in `S.HeapOptions(n)`, there is a move from `(m,n)` to
    * $(m,b_1_) + (m,b_2_) + \&ctdot; + (m,b_k_)$.
    *
    * The theory of acrostic products is discussed in \ww, Chapter 14; no general solution is known.
    */
  def AcrosticProduct(that as HeapRuleset) begin
    FunctionalCoordinateRuleset((m, n) -> begin
      var mOpts := [[(a, n) for a in mOpt] for mOpt in HeapOptions(m)];
      var nOpts := [[(m, b) for b in nOpt] for nOpt in that.HeapOptions(n)];
      mOpts Concat nOpts
      end
    )
  end

  /** The `HeapRuleset` obtained by adjoining moves from `that` to this ruleset.
    */
  def Adjoin(that as HeapRuleset) := FunctionalHeapRuleset(n -> HeapOptions(n) Concat that.HeapOptions(n));

  /** The cake product of this ruleset and `that`.
    *
    * `R.CakeProduct(S)` is equivalent to `game.heap.GenCutcake(R, S)`. See the documentation for
    * [[GenCutcake]] for details.
    */
  def CakeProduct(that as HeapRuleset, twisted as Boolean ? false) := GenCutcake(this, that, twisted);

  /** The direct product of this ruleset and `that`.
    *
    * `R.DirectProduct(S)` is a [[CoordinateRuleset]] whose structure is defined as follows.
    * The position `(m,n)` has one option for each ~pair~ of options `(m',n')`. For each such pair,
    * writing $m' = [a_1_,a_2_,\&hellip;a_k_]$ and $n' = [b_1_,b_2_,\&hellip;b_l_]$, there is an
    * option of `(m,n)` given by
    *
    * $\&Sigma;_i_(a_i_,n) + \&Sigma;_j_(m,b_j_) + \&Sigma;_i,j_(a_i_,b_j_)$.
    *
    * The direct product is related to the [[Integer#NimProduct][Nim product]] of integers: if an `R`-heap
    * of size `m` has Nim value `G(m)`, and an `S`-heap of size `n` has Nim value `G(n)`, then the position
    * `(m,n)` of `R.DirectProduct(S)` has Nim value $G(m) \otimes G(n)$.
    */
  def DirectProduct(that as HeapRuleset) begin
    FunctionalCoordinateRuleset((m, n) ->
      for mOpt in HeapOptions(m)
      for nOpt in that.HeapOptions(n)
      yield
        [(a, n) for a in mOpt] Concat [(m, b) for b in nOpt] Concat [(a, b) for a in mOpt for b in nOpt]
      end
    )
  end

  /** Constructs a position of this ruleset with the specified heap size.
    */
  def Eval(heapSize as Integer) := Position(heapSize);

  /** The options from the specified heap size.
    *
    * `HeapOptions` must always return a [[Collection]] of `Collection`s of nonnegative `Integer`s.
    */
  def HeapOptions(heapSize as Integer) := error("Subclasses of `HeapRuleset` must implement `HeapOptions`.");

  /** The nim value of the specified heap size.
    */
  external def HeapNimValue(heapSize as Integer);

  /** A [[List]] of nim values for all heaps up to the specified heap size.
    */
  external def NimValueSequence(toHeapSize as Integer);

  /** Checks for periodicity of this ruleset up to the specified heap size.
    *
    * If periodicity is detected, the result will be an instance of [[Periodicity]]. Otherwise,
    * the result will be [[Nothing]].
    */
  external def CheckPeriodicity(toHeapSize as Integer);

  /** A position of this ruleset.
    *
    * Subclasses do not need to implement a `Position` class directly and should instead implement
    * [[#HeapOptions]]. For efficiency reasons, calculating values of this heap game (such as by using
    * [[#NimValueSequence]]) will not result in `Position` objects being created. `Position` objects
    * will only be created when they are needed directly (for example, in the Explorer).
    */
  class Position(heapSize as Integer) extends ImpartialGame

    override def Options := HeapOptions(heapSize) Apply
      (heaps -> if heaps.IsEmpty then 0 else Sum(Position(n) for n in heaps) end);

    override def NimValue := HeapNimValue(heapSize);

  end

end
