/*${cgsuite.banner}*/

class GenClobber(
  directions as List of Coordinates ? Coordinates.Orthogonal,
  clobbered as Map of (Player, Set of Integer) ? {Left => {2}, Right => {1}},
  leftBehind as Map of (Player, Integer) ? {Left => 0, Right => 0},
  maxDistance as Integer ? 1
  ) extends GridRuleset

  var clobberedAsList := [clobbered[Left], clobbered[Right]];
  var leftBehindAsList := [leftBehind[Left], leftBehind[Right]];

  override def GridOptions(grid as Grid, player as Player) begin

    var us := player.Ordinal;

    var clob := clobberedAsList[us];
    var lb := leftBehindAsList[us];

    for c in grid FindAll us
    for d in directions
    for p in ClobberablePoints(grid, c, d, clob)
    yield
      grid Updated {c => lb, p => us}
    end

  end

  override def GridDecomposition(grid as Grid) begin
    if maxDistance == 1 then
      listof(Position(component) for component in grid.Decomposition(0, directions))
    else
      [grid]
    end
  end
  
  def ClobberablePoints(grid as Grid, c as Coordinates, d as Coordinates, clob as Collection of Integer) begin
    var n := 1;
    while n < maxDistance and grid[c+n*d] == 0 do
      n := n + 1;
    end
    // TODO This cast should be unnecessary
    (if clob Contains grid[c+n*d] then [c+n*d] else [] end) as List of Coordinates
  end

  override def CharMap := if clobbered.Values.Exists(x as Set of Integer -> x Contains 0) then ".xo#" else ".xo" end;

  override def Icons begin
  
    var bwIcons := [Icon.BlackStone, Icon.WhiteStone];
    if maxDistance == inf then
      if directions == Coordinates.Orthogonal then
        bwIcons := [Icon.BlackRook, Icon.WhiteRook];
      elseif directions == Coordinates.Compass then
        bwIcons := [Icon.BlackQueen, Icon.WhiteQueen];
      end
    elseif maxDistance == 1 then
      if directions == Coordinates.Compass then
        bwIcons := [Icon.BlackKing, Icon.WhiteKing];
      end
    end
    
    //if clobbered.Values Contains 0 then
    //  [Icon.Blank, bwIcons[1], bwIcons[2], Icon.GraySquare]
    //else
      [Icon.Blank, bwIcons[1], bwIcons[2]]
    //end
        
  end

end
