package org.cgsuite.core.impartial.arithmetic

import java.util

import com.typesafe.scalalogging.LazyLogging
import org.cgsuite.core.SmallInteger
import org.cgsuite.core.impartial.arithmetic.ImpartialTermAlgebra.Element

import scala.collection.mutable

object ImpartialTermAlgebra {

  def apply(qComponents: IndexedSeq[Int]): ImpartialTermAlgebra = {
    new ImpartialTermAlgebra(qComponents.distinct.sortBy(NimFieldCalculator.primePower).toArray)
  }

  object Element {

    def apply(terms: Seq[Int]): Element = new Element(terms.sorted)

  }

  case class Element private (terms: Seq[Int]) {

    def isOne: Boolean = {
      terms.size == 1 && terms.head == 0
    }

  }

}

// A representation of a finite nim subfield of omega^omega^omega. Elements of the
// algebra are represented as sums of "terms", where a term is the product of
// various "term components" kappa_q. Terms are represented as integers from 0 to N-1,
// where N is the total number of possible terms in the algebra.
// If kappa_{q_1}, ..., kappa_{q_k} are the components that generate the algebra, then
// N is given by N = p_1 * p_2 * ... * p_k, where p_i is the prime divisor of q_i.
// (example: in computing alpha_47, the relevant term algebra is generated by
// kappa_2, kappa_4, kappa_5, kappa_11, and kappa_23, so
// N = 2 * 2 * 5 * 11 * 23 = 5060.
// Then the term kappa_{q_1}^{a_1}kappa_{q_2}^{a_2}...kappa_{q_k}^{a_k} is represented by
// n = a_1 + p_1 * (a_2 + p_2 * (a_3 + p_3 * ( ... ))).
// All calculations in the term algebra are then reduced to integer operations.
class ImpartialTermAlgebra private (val qComponents: Array[Int]) extends LazyLogging {

  // The degree of each q_i: the prime p_i such that q_i is a power of p_i.
  val qDegrees = qComponents map { NimFieldCalculator.primePower(_)._1 }

  // Validate that qComponents is closed under q => q/p and properly ordered.
  qComponents.indices foreach { i =>
    val q = qComponents(i)
    val p = qDegrees(i)
    if (q == p) {
      assert(i == 0 || p > qDegrees(i - 1))
    } else {
      assert(i != 0 && qComponents(i - 1) == q / p)
    }
  }

  // The term corresponding to each primitive component kappa_{q_i},
  // equal to the partial degree product p_1 * p_2 * ... * p_{i-1}.
  // basis(i) corresponds to qComponents(i), and basis(qComponents.length)
  // is the product of all the degrees, equal to the size of the term algebra.
  // In particular:
  // basis(0) == 1
  // basis(qDegress.length) == N == number of terms in the algebra.
  // basis(i) == basis(i - 1) * qDegrees(i)   (i > 0)
  val basis = (0 to qDegrees.length).map { qDegrees.take(_).product }.toArray
  val termCount = basis.last

  // A buffer for accumulation calculations.
  val accumulator = new Array[Long]((termCount + 63) >> 6)

  // First compute, for each component kappa_q, the element given by
  // kappa_q^p (where p is the prime divisor of q).
  // cf. Lenstra (1.5)-(1.7).
  val kappaTable: IndexedSeq[Element] = qComponents.indices map { index =>
    (qComponents(index), qDegrees(index)) match {
      case (_, 2) =>
        // Case p = 2: given by Lenstra (1.5)
        Element(Seq(basis(index), basis(index) - 1))
      case (q, p) if q == p =>
        val qSet = NimFieldCalculator.qSet(p)
        val excess = NimFieldCalculator.excess(p)
        assert(excess == 0 || excess == 1 || SmallInteger.isTwoPower(excess))
        val kappaBlocks = qSet.map { q2 =>
          val index = qComponents.indexOf(q2)
          assert(index >= 0, s"$q2 not in ${qComponents.toSeq}")
          basis(index)
        }
        Element(excess match {
          case 0 => kappaBlocks
          case _ => kappaBlocks :+ SmallInteger.lb(excess)
        })
      case _ => Element(Seq(basis(index - 1)))
    }
  }

  logger.info {
    val ktStrings = kappaTable map { element => s"{${element.terms.sorted mkString ","}}" }
    s"(q, kappa_q^p)   =   ${qComponents zip ktStrings map { case (q, ktString) => s"$q -> $ktString"} mkString "   "}"
  }

  //for (index <- qComponents.indices) { println(s"${qComponents(index)}: ${kappaTable(index) mkString ","}") }

  // This table caches the result of kappa_{q_i}^j * t, for each i, each j with
  // 0 <= j < p_i, and each term t.
  // In particular, qPowerTimesTermTable(i)(j)(t) is equal to the term that
  // represents kappa_{qComponents(i)}^j * t.
  // Begin by initializing the table with empty arrays.
  val qPowerTimesTermTable = new Array[Array[Array[Element]]](qComponents.length)
  qPowerTimesTermTable.indices foreach { index =>
    qPowerTimesTermTable(index) = new Array[Array[Element]](qDegrees(index))
    1 until qDegrees(index) foreach { qExponent =>
      qPowerTimesTermTable(index)(qExponent) = new Array[Element](termCount)
    }
  }

  // Now compute each element of the table.
  for (qIndex <- qComponents.indices;
       qExponent <- 1 until qDegrees(qIndex);
       term <- 0 until termCount) {
    qPowerTimesTerm(qIndex, qExponent, term)
  }

  def qPowerTimesTerm(qIndex: Int, qExponent: Int, term: Int): Element = {

    val cached = qPowerTimesTermTable(qIndex)(qExponent)(term)
    if (cached != null) {
      cached
    } else {
      val result = qPowerTimesTermCalc(qIndex, qExponent, term)
      qPowerTimesTermTable(qIndex)(qExponent)(term) = result
      result
    }

  }

  def qPowerTimesTermCalc(qIndex: Int, qExponent: Int, term: Int): Element = {

    val p = qDegrees(qIndex)
    val qExponentInTerm = (term % basis(qIndex + 1)) / basis(qIndex)
    val qExponentNew = qExponent + qExponentInTerm

    if (qExponentNew < p) {
      Element(Seq(term + qExponent * basis(qIndex)))
    } else {

      assert(qExponentNew < 2 * p)
      val highOrderPart: Int = (term / basis(qIndex + 1)) * basis(qIndex + 1) + (qExponentNew % p) * basis(qIndex)
      val lowOrderPart: Int = term % basis(qIndex)
      logger.debug("parts = " + highOrderPart + "," + lowOrderPart)
      // We want to return highOrderPart * (lowOrderPart * kappa^p).
      // Retrieve the summands of kappa^p.
      val kappaExpansion = kappaTable(qIndex)
      logger.debug("kexp = " + kappaExpansion)
      // Compute the summands of lowOrderPart * kappa^p.
      val terms = mutable.Set[Int]()
      for (term <- kappaExpansion.terms) {
        for (productTerm <- termTimesTerm(lowOrderPart, term).terms) {
          if (terms.contains(productTerm))
            terms.remove(productTerm)
          else
            terms.add(productTerm)
        }
      }
      Element(terms.toSeq.sorted map { highOrderPart + _ })

    }

  }

  def termTimesTerm(x: Int, y: Int): Element = {
    assert(x >= 0)
    assert(y >= 0)
    var terms = mutable.Set(y)
    for (xIndex <- qComponents.length - 1 to 0 by -1) {
      val xExponent = (x % basis(xIndex + 1)) / basis(xIndex)
      if (xExponent > 0) {
        val newTerms = mutable.Set[Int]()
        for (term <- terms) {
          for (productTerm <- qPowerTimesTerm(xIndex, xExponent, term).terms) {
            if (newTerms.contains(productTerm)) newTerms.remove(productTerm)
            else newTerms.add(productTerm)
          }
        }
        terms = newTerms
      }
    }
    Element(terms.toSeq.sorted)
  }

  @inline
  private def flipAccumulatorTerm(x: Int): Unit = {
    accumulator(x / 64) ^= 1L << x
  }

  private def accumulatorContains(x: Int): Boolean = {
    (accumulator(x / 64) & (1L << x)) != 0
  }

  def accumulateTermProduct(x: Int, y: Int): Unit = {
    if (y == 0) {
      flipAccumulatorTerm(x)
    } else {
      // Take the highest-order remaining qComponent from y.
      var index = qComponents.length
      while (y / basis(index) == 0) {
        index -= 1
      }
      // Multiply that component by x to get a sum of terms.
      val product = qPowerTimesTerm(index, y / basis(index), x)
      // Apply each component of the sum.
      for (term <- product.terms) {
        accumulateTermProduct(term, y % basis(index))
      }
    }
  }

  def multiply(a: Element, b: Element): Element = {
    util.Arrays.fill(accumulator, 0)
    for (x <- a.terms; y <- b.terms) {
      accumulateTermProduct(x, y)
    }
    Element(0 until termCount collect {
      case x if accumulatorContains(x) => x
    })
  }

  // We can take advantage of characteristic 2 to provide an implementation
  // of square(a) that is faster than multiply(a, a).
  def square(a: Element): Element = {
    util.Arrays.fill(accumulator, 0)
    for (x <- a.terms) {
      accumulateTermProduct(x, x)
    }
    Element(0 until termCount collect {
      case x if accumulatorContains(x) => x
    })
  }

  def pow(x: Element, n: BigInt): Element = {
    var curpow: Element = x
    var result: Element = Element(Seq(0))
    var i = n
    var checkpointTime = System.currentTimeMillis()
    while (i != BigInt(0)) {
      if (i.testBit(0)) {
        result = multiply(result, curpow)
      }
      curpow = square(curpow)
      if (System.currentTimeMillis() - checkpointTime >= 60000L) {
        val bitsComplete = n.bitLength - i.bitLength
        logger.info(f"$bitsComplete/${n.bitLength} bits complete (${bitsComplete.toDouble/n.bitLength}%2.1f%%); curpow/result has ${curpow.terms.size}/${result.terms.size} terms")
        checkpointTime = System.currentTimeMillis()
      }
      i >>= 1
    }
    result
  }

}
