<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Functions and Lists</title>
</head>

<body bgcolor="#FFFFFF">

<h1>Functions and Lists</h1>

    <p>This section of the tutorial describes two powerful new tools that were 
    added in version 0.4: <i>functions</i> and <i>lists</i>.</p>
    
    <h3>Contents</h3>
    
    <ul>
      <li><a href="#Functions">Functions</a></li>
      <li><a href="#ExampleBlockbusting">Example: Blockbusting</a></li>
      <li><a href="#SeqKeyword">The <i>seq</i> Keyword</a></li>
      <li><a href="#TabulateKeyword">Organizing Results with <i>tabulate</i></a></li>
      <li><a href="#MoreAboutLists">More about Lists</a></li>
      <li><a href="#ExamplePartizanSubtraction">Example: Partizan Subtraction 
      Games</a></li>
      <li><a href="#Exercises">Exercises</a></li>
</ul>
    
    <h3><a name="Functions"></a>Functions</h3>
    
    <p>Combinatorial Game Suite permits user-defined functions.&nbsp; A function 
    can be a simple mapping between objects or a more complicated recursive 
    definition.&nbsp; As a simple example, the following function sets up the 
    mapping <code><i>n</i> -&gt; <i>n</i>.^</code>:</p>
    
    <p><code>f(n_) := n.^</code></p>
    
    <p>The underscore _ indicates that the function is being defined for <i>all</i> 
    values of <i>n</i>, rather than for a single specific value.&nbsp; After 
    defining <i>f</i>, you can access its values by typing simply (for example):</p>
    
    <p><code>f(2)</code></p>
    
    <p>To construct a recursive definition, specify the general rule in 
    conjunction with any number of base cases (typed in as separate statements).&nbsp; 
    For example, the following is an alternative way to specify the mapping <code><i>n</i> 
    -&gt; <i>n</i>.^</code>:</p>
    
<pre><code>g(0) := 0;
g(n_) := {0|g(n-1)+*}</code></pre>
<p>Try typing <code>g(2)</code> to check that it works.&nbsp; Notice that this 
is just the usual recursive definition of the canonical form of <code><i>n</i>.^</code>.</p>
<p>Combinatorial Game Suite keeps track of all the previously computed values of 
a function.&nbsp; It also remembers whether a value was entered manually (as a 
base case) or computed automatically (using a recursive definition).&nbsp; If 
you change the function by entering new base cases, redefining old ones, or 
changing the recursive definition, then all of the <i>calculated</i> values will 
be cleared (but not the manually entered ones).</p>
<p>You can  type <code>clear(f)</code> at any time to destroy any existing information about <i>f</i>.</p>
<h3><a name="ExampleBlockbusting"></a>Example: Blockbusting</h3>
<p>One of the most useful applications of functions is to specify recursively 
the positions of a game.&nbsp; As an example, we'll write a function that 
calculates the values of blockbusting positions.&nbsp; <i>Blockbusting</i> is a simple game played on a 1x<i>n</i> or <i>n</i>x1 grid.  Left, on his turn, places a bLue house on any empty square; Right places a Red house on any empty square.  The game ends when no empty squares remain on the grid.  Once play has finished, the players tally up their scores.  If the grid is 1x<i>n</i> (horizontaL), then Left scores one point (that is, one free move) for each pair of adjacent bLue houses; if the grid is <i>n</i>x1 (veRtical), then Right scores one point for each pair of adjacent Red houses.  For example, if the final position on a 1x10 grid is <code>RRLLLLRRLL</code>, then its value is 4: one point for the <code>LL</code> at the end, and three points for the <code>LLLL</code> (note that the four adjacent <code>L</code>'s count as three pairs.)  The value of the corresponding 10x1 position is -2.  (Note that since Right can never score on a 1x<i>n</i> grid, no horizontal Blockbusting position has value &lt; 0, and likewise no vertical Blockbusting position has value &gt; 0.)</p>
<p>Notice that every horizontal Blockbusting position can be decomposed as the sum of 
&quot;atomic&quot; positions - those of the form L<i>n</i>L (a bLue house followed by <i>n</i> 
empty squares followed by another bLue house), L<i>n</i>R, or R<i>n</i>R, where<i> 
n</i> may be 0.<i>&nbsp; </i>(R<i>n</i>L is equivalent to L<i>n</i>R by 
symmetry.)&nbsp; Thus for example, <code>R..LL...L = L2R + L0L + L3L</code>.&nbsp; 
This means we can completely solve blockbusting by writing functions <code>LL(n)</code>, <code>LR(n)</code>, 
and <code>RR(n)</code> that respectively calculate the values of L<i>n</i>L, L<i>n</i>R, 
and R<i>n</i>R (horizontal) blockbusting.</p>
<p>This is not quite as easy as specifying <i>n</i>.^ recursively, however: 
While <i>n</i>.^ has only one left option and one right option, Blockbusting 
positions of length <i>n</i> have <i>n</i> options available to each player.&nbsp; 
The <i>seq</i> keyword, discussed next, provides a convenient way to specify 
large sets of options.</p>
<h3><a name="SeqKeyword"></a>The <i>seq</i> Keyword and a Blockbusting Solution</h3>
<p>You can use the <i>seq</i> keyword to specify a list of objects described 
by a parameter.&nbsp; As a first example, try entering the following:</p>
<p><code>seq(2.n, n=0..5)</code></p>

<p>You'll see the following result:</p>

<p><code>[0,2,4,6,8,10]</code></p>

<p>The brackets [ ] indicate that a <i>list</i> of objects has been specified.&nbsp; 
Notice that this list represents the sequence ( 2<i>n</i> : 0 &lt;= <i>n</i> &lt;= 5 
).&nbsp; 
Generally speaking, typing</p>

<p><code>seq(<i>expression</i>, <i>variable</i>=<i>m</i>..<i>n</i>)</code></p>

<p>evaluates the <i>expression</i> as the <i>variable</i> ranges from <i>m</i> 
to <i>n</i> (inclusive), and places the results into a list.&nbsp; This provides 
a way to specify the left and right options of the Blockbusting examples 
specified above.&nbsp; Consider, for example, the case L4R.&nbsp; Left can place 
his house into any of the four available positions.&nbsp; His moves are to L0L + 
L3R, L1L+L2R, L2L+L1R, and L3L+L0R.&nbsp; Generalizing, Left's moves from L<i>n</i>R 
are L0L+L(<i>n</i>-1)R, L1L+L(<i>n</i>-2)R, ..., L(<i>n</i>-1)L+L0R.&nbsp; So 
Left's set of moves is { L<i>k</i>L+L(<i>n</i>-<i>k</i>-1)R : 0 &lt;= <i>k</i> &lt;=
<i>n</i>-1 }.&nbsp; In terms of the functions <code>LL(n)</code> and <code>LR(n)</code> 
that we wish to define, this suggests the following representation for Left's 
options from L<i>n</i>R:</p>

<p><code>seq(LL(k) + LR(n-k-1), k=0..n-1)</code></p>

<p>Typing this in directly will produce an error, though, since we haven't yet 
defined <code>LL</code> and <code>LR</code>.&nbsp; But we can use it safely from 
within the definition of LR.&nbsp; Likewise, Right's options from L<i>n</i>R are 
given by:</p>

<p><code>seq(LR(k) + RR(n-k-1), k=0..n-1)</code></p>

<p>So we can define L<i>n</i>R by:</p>

<pre><code>LR(n_) := { seq(LL(k) + LR(n-k-1), k=0..n-1)
          | seq(LR(k) + RR(n-k-1), k=0..n-1) }</code></pre>
<p>A similar analysis of L<i>n</i>L and R<i>n</i>R leads to the following complete definition of 
Blockbusting, which you can copy and paste into the worksheet (it's safe to 
paste the whole thing onto a single line):</p>
<pre><code>LL(0) := 1;

LL(n_) := { seq(LL(k)+LL(n-k-1), k=0..n-1)
          | seq(LR(k)+LR(n-k-1), k=0..n-1) };

LR(n_) := { seq(LL(k)+LR(n-k-1), k=0..n-1)
          | seq(LR(k)+RR(n-k-1), k=0..n-1) };

RR(n_) := { seq(LR(k)+LR(n-k-1), k=0..n-1)
          | seq(RR(k)+RR(n-k-1), k=0..n-1) };</code></pre>
<p>Notice that although we specified a base case <code>LL(0) := 1</code>, we 
don't need to specify explicit base cases for <code>LR</code> and <code>RR</code>, 
since <code>LR(0)</code> and <code>RR(0)</code> will automatically evaluate to 
empty sets of options for both players.</p>
<p>Try typing <code>LL(20)</code> to test the new definition!</p>
<h3><a name="TabulateKeyword"></a>Organizing Results with <i>tabulate</i></h3>
<p>The <i>tabulate</i> keyword provides a way to organize results into 
nicely-formatted tables.&nbsp; The use of <i>tabulate</i> is very similar to<i> 
seq</i> and is best illustrated with an example.&nbsp; First read through the 
previous section and make sure you've entered the definitions of <code>LL</code>, <code>LR</code>, 
and <code>RR</code> provided there.&nbsp; Then type:</p>
<p><code>tabulate(n, LL(n), LR(n), RR(n), n=1..15)</code></p>
<p>This produces a table with 15 rows and 4 columns; each row contains <i>n</i> 
together with the values of L<i>n</i>L, L<i>n</i>R, and R<i>n</i>R Blockbusting.&nbsp; 
In general, typing</p>
<p><code>tabulate(<i>expression1</i>, <i>expression2</i>, ..., <i>variable</i>=<i>m</i>..<i>n</i>)</code></p>
<p>evaluates each <i>expression</i> as the <i>variable</i> ranges between <i>m</i> 
and <i>n</i> (inclusive), and places the results into a table.&nbsp; There can 
be as many expressions as you need.</p>
<h3><a name="MoreAboutLists"></a>More about Lists</h3>
<p>Recall that <code>seq(2.n, n=0..5)</code> creates a <i>list</i> of 
integers: <code>[0,2,4,6,8,10]</code>.&nbsp; There are various other ways that 
lists can arise.&nbsp; For example, typing <code>LeftOptions(G)</code> creates a 
list containing all left options of <code>G</code>; so <code>LeftOptions(^*)</code> 
returns <code>[0,*]</code>.</p>

<p>Individual list elements can be referenced using brackets: If <code>L</code> 
is a list, then <code>L[n]</code> is the <i>n</i><sup>th</sup> element of <code>L</code>.&nbsp; 
Lists can also be entered directly by enclosing the elements in brackets.&nbsp; 
An example:</p>
<p><code>L := [*,vv,1/2]</code></p>
<p>Then <code>L[1]</code> is <code>*</code>, <code>L[2]</code> is <code>vv</code>, 
and <code>L[3]</code> is <code>1/2</code>.</p>
<p>If <code>L</code> is a list, then <code>Length(L)</code> gives the number of 
elements in <code>L</code>.</p>

<h3><a name="ExamplePartizanSubtraction"></a>Example: Partizan Subtraction Games</h3>
<p>Here's a more complicated example that combines functions and lists.&nbsp; A <i>partizan subtraction game</i> begins with a heap of <i>n</i> beans.&nbsp; 
On his turn, Left must remove <i>k</i> beans from the heap, where <i>k</i> is 
chosen from some fixed finite set <i>L </i>of integers.&nbsp; Right must do 
likewise, choosing from some (possibly different) set <i>R</i>.&nbsp; The first 
player unable to move loses.&nbsp; We denote this game by <i>S<sub>L,R,n</sub></i>.&nbsp; 
Note that Left's options from <i>S<sub>L,R,n</sub></i> consist of <i>S<sub>L,R,n-k</sub></i> 
for all <i>k</i> in <i>L</i> with <i>k</i> &lt;= <i>n</i>.&nbsp; The subtraction 
sets remain the same, and only the heap size changes.</p>


<p>In this example we'll define a single recursive function <code>subtgame(L,R,n)</code> that specifies <i>all</i> 
partizan subtraction games.&nbsp; The function takes three parameters - two 
lists, <code>L</code> and <code>R</code>, representing Left's and Right's subtraction sets, 
and an integer <code>n</code>, specifying the size of the heap.&nbsp; For 
example, the subtraction game <i>S<sub>{1,3,5},{2,4},10</sub></i><sub> </sub>
would be entered as <code>subtgame([1,3,5],[2,4],10)</code>.We'll specify the 
Left options of <code>subtgame(L,R,n)</code> using <i>seq</i>, as in the 
Blockbusting example.&nbsp; This time, we'll let the variable <code>k</code> <i>
index</i> the list <code>L</code>.&nbsp; From <code>subtgame(L,R,n)</code>, Left 
can move to <code>subtgame(L,R,n-L[k])</code> as <code>k</code> ranges between 1 
and the length of <code>L</code>.&nbsp; So we want something like the following:</p>


<pre><code>seq(subtgame(L,R,n-L[k]), k=1..Length(L))</code></pre>
<p>There's one catch, however.&nbsp; <code>n-L[k]</code> might be negative if <code>n</code> 
is very small.&nbsp; The solution is to tack on an optional third parameter to
<i>seq</i>: A condition that determines individually which elements to 
include.&nbsp; Here's a correct description of Left's options:</p>
<pre><code>seq(subtgame(L,R,n-L[k]), k=1..Length(L), L[k] &lt;= n)</code></pre>
<p>Right's options are specified similarly, leading to the following definition 
of <code>subtgame</code>, which you can copy-paste into the worksheet:</p>


<pre><code>subtgame(L_,R_,n_) :=
  { seq(subtgame(L,R,n-L[k]), k=1..Length(L), L[k] &lt;= n)
  | seq(subtgame(L,R,n-R[k]), k=1..Length(R), R[k] &lt;= n) };</code></pre>
<p>Try typing <code>subtgame([1,3,5],[2,4],10)</code> to evaluate the example 
described above.</p>


<h3><a name="Exercises"></a>Exercises</h3>
<p>1. Tabulate the values of <i>S<sub>{1,2},{2,3},n</sub></i>, <i>S<sub>{1,3},{2,4},n</sub></i> 
  and <i>S<sub>{2,3},{3,4},n</sub></i> for 1 &lt;= n &lt;= 10.</p>
<p>2. The game <i>Seating Boys and Girls</i> is described in Winning Ways.&nbsp; 
  Left seats boys around a circular table with <i>n</i> chairs, and Right seats 
  girls, with the restriction that no child may be seated next to one of the 
  opposite sex.&nbsp; Assuming at least one child has been seated, the position 
  is the sum of L<i>n</i>L, L<i>n</i>R, and/or R<i>n</i>R for various n, just as 
  for Blockbusting.&nbsp; Write functions <code>LL</code>, <code>LR</code>, and <code>RR</code> 
  that compute positions in Seating Boys and Girls and tabulate the values up to<i> 
  n</i>=10.<i>&nbsp; </i>Compare your answers to those given in Winning Ways.&nbsp; 
  Try computing L15R separately (not in a table) and note that the game is very 
  complicated indeed!</p>
<p>3. Rewrite <code>subtgame</code> using functions rather than lists, to allow 
  for possibly infinite subtraction sets.&nbsp; The result should be a function <code>fsubtgame(f,g,n)</code> 
  that takes as parameters two <i>functions</i>,<i> f</i> and <i>g</i>, and the 
  heap size <i>n</i>.&nbsp; Left can remove <code>f(k)</code> beans from the 
  heap for any <code>k &gt;= 1</code>, and likewise Right can remove <code>g(k)</code> 
  beans.&nbsp; You may assume that Left's options from a heap of size<i> n</i> 
  are limited to (at most) <code>f(1), ..., f(n)</code>, and likewise for Right.&nbsp; 
  (This sacrifices no generality: We can represent any infinite subtraction set 
  by a function <i>f</i> that is strictly increasing, whereupon necessarily <code>f(n) &gt;= n</code> 
  for all <i>n</i>.)&nbsp; Test your function by tabulating some values 
  of the <i>odd-even subtraction game</i> where Left can remove an odd number of 
  beans from the heap, and Right an even number.&nbsp; Verify that even heap 
  sizes are numbers, while odd heap sizes have mean and temperature 1/2.</p>
<hr>
Continue on to <a href="scripts.html">Writing Scripts</a></body></html>