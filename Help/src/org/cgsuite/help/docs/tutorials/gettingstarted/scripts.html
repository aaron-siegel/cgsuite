<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Writing Scripts</title>
</head>

<body bgcolor="#FFFFFF">

<h1>Writing Scripts</h1>
<h3>Contents</h3>
<ul>
  <li><a href="#Scripts">Scripts in CGSuite</a></li>
  <li><a href="#UsingOut">Using <i>out</i> to Display Output</a></li>
  <li><a href="#IfThenElse"><i>if-then-else</i> Statements</a></li>
  <li><a href="#ForLoops"><i>for</i> Loops</a></li>
  <li><a href="#Procedures">Procedures</a></li>
  <li><a href="#LogErr"><i>log</i> and <i>err</i></a></li>
  <li><a href="#Domineering">Example: Domineering</a></li>
  <li><a href="#Exercises">Exercises</a></li>
</ul>
<h3><a name="Scripts"></a>Scripts in CGSuite</h3>

<p>In addition to recursive function definitions (see the
<a href="functions.html">previous section</a> of this tutorial), Combinatorial 
Game Suite supports several scripting commands, including if/then/else 
statements and for loops.&nbsp; CGSuite's language is modeled after other common 
scripting languages; its syntax and structure should be recognizable to anyone 
familiar with, say, Maple or Visual Basic.</p>

<p>Like all other commands, scripts may be entered directly onto the worksheet.&nbsp; 
However, the entire script must be entered into a single worksheet field, and 
since scripts generally consist of long sequences of commands, this can be 
somewhat cumbersome.&nbsp; Alternatively, a script may be composed in an 
external text editor (such as GNU Emacs) and run in CGSuite by selecting &quot;Run 
Script ...&quot; from the File menu.&nbsp; The entire file containing the script is 
treated as if it were entered into a single worksheet field.&nbsp; You may 
choose to direct the script's output either to a new worksheet or to a text 
file.</p>

<h3><a name="UsingOut"></a>Using <i>out</i> to Display Output</h3>

<p>As noted previously in this tutorial, multiple commands may be strung 
together in sequence using semicolons.&nbsp; For example:</p>

<p><code>g := 3; g := g + 2; g + 5</code></p>

<p>This would output <code>10</code>.&nbsp; Notice that output is generated only 
for the last command in a sequence; it is suppressed for each intermediate 
command.&nbsp; If the sequence ends with a semicolon, no output is generated at 
all.</p>

<p>If you want to display output for intermediate commands, you can append&nbsp; <code>&gt;&gt; out</code>&nbsp; to 
the end of an expression.&nbsp; For example:</p>

<p><code>g := 3 &gt;&gt; out; g := g + 2 &gt;&gt; out; g + 5 &gt;&gt; out;</code></p>

<p>This would output <code>3</code>, <code>5</code>, and <code>10</code>, each 
on a separate line.</p>

<h3><i><a name="IfThenElse"></a>if-then-else</i> Statements</h3>
<p>The general form of the <i>if-then-else</i> statement is:</p>

<p><code>if <i>condition</i> then <i>statements</i> [elif <i>condition</i> then 
<i>statements</i>] [else <i>statements</i>] fi</code></p>

<p>Here and throughout this section, an expression enclosed in brackets [ ] is 
optional and may be omitted.&nbsp; <i>statements</i> can be any single command, or any sequence of commands separated by semicolons.&nbsp; Any number 
(zero or more) of &quot;<code>elif <i>condition</i> then <i>statements</i></code>&quot; clauses may be 
included.&nbsp; CGSuite will run the statement(s) following the first <i>condition</i> 
that evaluates to <i>true</i>, and only those statements.&nbsp; If none of the <i>
condition</i>s is true, and an <i>else</i> clause is present, CGSuite will run 
its statement(s).&nbsp; The following code tests how <code>g</code> compares with <code>0</code> 
and displays a useful message:</p>

<pre><code>if g &lt; 0 then &quot;negative&quot; &gt;&gt; out;
elif g &gt; 0 then &quot;positive&quot; &gt;&gt; out;
elif g == 0 then &quot;zero&quot; &gt;&gt; out;
else &quot;fuzzy&quot; &gt;&gt; out;
fi</code></pre>



<h3><i><a name="ForLoops"></a>for</i> Loops</h3>
<p>The general form of the <i>for</i> statement is:</p>
<p><code>[for <i>variable</i>] [from <i>expression</i>] [to <i>expression</i>] [by <i>
expression</i>] [while <i>condition</i>] [where<i> condition</i>]<i> </i>do <i>
statements</i> od</code></p>

<p>As before, any bracketed expression is optional, and <i>statements</i> can be replaced by any command 
or sequence of commands.&nbsp; Each of the <i>expression</i>s must be a canonical game (or 
some more complicated expression that evaluates to a canonical game), and the <i>
conditions</i> must be boolean values (<code>true</code> or <code>false</code>).&nbsp; 
CGSuite interprets the <i>for</i> statement as follows:</p>

<ol>
  <li>Set the value of <i>variable</i> to match the <i>from</i> expression.</li>
  <li>If the value of <i>variable</i> is greater than or confused with the <i>to</i> 
  expression, or if the <i>while</i> condition fails, then exit the loop 
  immediately.</li>
  <li>If the <i>where</i> condition holds, perform the statement(s) between <code>do</code> 
  and <code>od</code>.</li>
  <li>Increase the value of <i>variable</i> by the <i>by</i> expression, and 
  repeat step 2.</li>
</ol>

<p>If any of <i>from</i>, <i>to</i>, or <i>by</i> are omitted, then the default 
values are 1, infinity, 
and 1, respectively.&nbsp; The default <i>conditions</i> are always <code>true</code>.</p>

<p>The following example simply prints out all even integers between 2 and 10:</p>

<pre><code>for n from 2 to 10 by 2 do
    n &gt;&gt; out;
od
</code></pre>
<p>The same effect could be achieved using <i>while</i>:</p>
<pre><code>n := 2;
while n &lt;= 10 do
    n &gt;&gt; out;
    n := n + 2;
od</code></pre>
<p>Finally, there is an alternate form of the <i>for</i> statement:</p>

<p><code>[for <i>variable</i>] [in <i>expression</i>] [while<i> condition</i>] 
[where <i>condition</i>]<i> </i>do <i>statements</i> od</code></p>

<p>In this form, the <i>in</i> expression should evaluate to a list of objects, and 
the statements(s) between <code>do</code> and <code>od</code> will be repeated once 
for each element of the list.&nbsp; <i>while </i>and<i> where </i>have the same 
meanings as before.&nbsp; The following example displays all good left 
options in 4x4 Domineering together with their canonical forms:</p>

<pre><code>for g in SensibleLeftOptions(DomineeringRectangle(4,4)) do
    g >> out;
    C(g) >> out;
od</code></pre>


<p>You can use the <code>break</code> command within a loop to terminate the 
loop immediately, and <code>continue</code> to continue the loop.</p>


<p>Either type of loop can be used in <i>seq</i> and <i>tabulate</i> 
expressions, for example:</p>


<pre><code>seq(n.^ for n from 1 to 5) &gt;&gt; out;
tabulate(h, C(h) for h in LeftOptions(g)) &gt;&gt; out;</code></pre>
<h3><a name="Procedures"></a>Procedures</h3>
<p>A <i>procedure</i> is a user-defined function.&nbsp; We met one type of 
procedure - recursive functions - in the previous section of this tutorial.&nbsp; 
Procedures can also be designed to execute a sequence of commands, rather than 
simply evaluate one expression.&nbsp; In such cases it's easiest to use the 
following alternate syntax for defining a procedure:</p>


<p><code>proc(<i>variable-list</i>) [local <i>variable-list</i>;] [option 
remember;] <i>
statements</i> end</code></p>


<p>The following two examples define the same function <i>f</i>:</p>


<pre><code>f(n_) := n + 1;
f := proc(n) n + 1 end;</code></pre>
<p>There is a crucial difference between these two forms.&nbsp; Procedures 
defined using <code>f(n_)</code> will store their values in a cache as they are 
computed, making recursive calculations vastly more efficient.&nbsp; Procedures 
defined using <code>proc(n)</code> will not cache values by default, but you can 
override this behavior by inserting <code>option remember;</code> immediately 
before the body of the procedure.&nbsp; Contrast the following two definitions:</p>
<pre><code>slowfib := proc(n)
    if n == 0 or n == 1 then 1
    else slowfib(n-1) + slowfib(n-2) fi
end;

fastfib := proc(n) option remember;
    if n == 0 or n == 1 then 1
    else fastfib(n-1) + fastfib(n-2) fi
end;</code></pre>
<p>Both calculate fibonacci numbers, but <code>fastfib</code> is substantially 
more efficient (linear time instead of exponential).</p>
<p>Procedures can also take several parameters.&nbsp; Here's an example that 
computes the maximum of two integers:</p>


<pre><code>max := proc(m,n)
    if m &lt;= n then n else m fi
end;</code></pre>
<p>Procedures can take any object as parameters, not just games.&nbsp; Here's a 
more sophisticated example that takes a <i>list</i> of games (as described in 
the previous section) and returns the sum of all games in the list.</p>
<pre><code>listsum := proc(L) local i, g;
    g := 0;
    for i from 1 to Length(L) do
        g := g + L[i];
    od;
    g
end;</code></pre>
<p>For example, typing <code>listsum([3*,vv,^*])</code> would return <code>3v</code>.&nbsp; 
Notice that in procedures involving multiple statements, the value returned by 
the procedure is equal to the value of the last statement in the sequence (<i>unless</i> 
that statement ends in a semicolon, in which case the procedure returns no 
value).&nbsp; Also note the use of <code>local i, g;</code> in the procedure 
definition: This marks <code>i</code> and <code>g</code> as local variables for the procedure, so 
that calls to <code>listsum</code> will not affect the value of the global <code>
i</code> and <code>g</code>.</p>
<p>You can also use <code>return</code> statements from within a procedure.&nbsp; 
If&nbsp; <code>return <i>expression</i></code>&nbsp; is encountered at any point 
during the procedure's execution, then it immediately terminates with value 
equal to the expression.</p>
<p>A third &quot;shorthand&quot; notation for procedures is sometimes useful.&nbsp; The 
following definitions of <code>f</code> and <code>max</code>, equivalent to 
those given above, illustrate this notation:</p>
<pre><code>f := n -&gt; n + 1;
max := (m,n) -&gt; if m &lt;= n then n else m fi;</code></pre>
<p>Procedures defined using <code>-&gt;</code> will <i>never</i> cache values, 
so they should not be used for recursive calculations.</p>
<h3><i><a name="LogErr"></a>log</i> and <i>err</i></h3>
<p>Recall that appending <code>&gt;&gt; out</code> to an expression simply 
outputs the value of the expression; for example:</p>
<p><code>&quot;Hello&quot; &gt;&gt; out;</code></p>
<p>Two similar constructions are useful.&nbsp; The following:</p>
<p><code><i>expression </i>&gt;&gt; log;</code></p>
<p>inserts the value of <i>expression</i> into the kernel log.&nbsp; This is 
useful primarily when you want to track the progress of a calculation from 
within a script, without distorting your output file.&nbsp; Finally,</p>
<p><code><i>expression</i> &gt;&gt; err;</code></p>
<p>causes the entire script to terminate immediately and display the value of <i>
expression</i> as an error message.&nbsp; This is useful for handling error 
conditions within procedures.&nbsp; Here's an improved version of the <code>max</code> 
procedure, which operates on any pair of games and displays an error message if 
they are incomparable:</p>
<pre><code>max := proc(g,h)
    if g &lt;= h then h
    elif h &lt;= g then g
    else &quot;The games are incomparable.&quot; &gt;&gt; err
    fi
end;</code></pre>
<h3><a name="Domineering"></a>Example: Domineering</h3>


<p>The usual way to construct game positions in the Worksheet is to pass a list 
of strings to the appropriate method.&nbsp; For example:</p>


<p><code>Amazons(&quot;L...&quot;,&quot;R...&quot;)</code></p>


<p>While this is straightforward to enter directly, it's highly inconvenient for 
scripts that need to iterate over a class of game positions.&nbsp; An 
alternative construction is provided for this purpose: A game position can be 
represented by a two-dimensional array of one-character strings.&nbsp; (A 
two-dimensional array is just a list of lists.)&nbsp; Here are three ways to 
construct the same Amazons position:</p>


<pre><code>Amazons(&quot;L...&quot;,&quot;R...&quot;)
Amazons([&quot;L...&quot;,&quot;R...&quot;])
Amazons([[&quot;L&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]])</code></pre>
<p>The third construction is extremely awkward to type directly, but it's quite 
convenient for use in scripts.&nbsp; The following simple example illustrates 
how it's used.&nbsp; It creates a table showing the canonical forms of all 3x3 
Domineering positions with just one square blocked.&nbsp; Note the use of the 
methods <code>CreateTable</code> and <code>AddTableRow</code> to construct and 
populate a table with two columns.</p>


<pre><code>table := CreateTable(2);
AddTableRow(table, &quot;Position&quot;, &quot;Value&quot;);

// Initialize the grid
for row from 1 to 3 do
  for col from 1 to 3 do
    grid[row][col] := &quot;.&quot;;
od od;

for row from 1 to 3 do
  for col from 1 to 3 do
    grid[row][col] := &quot;x&quot;; // Block this square
    g := Domineering(grid);
    AddTableRow(table, g, C(g));
    grid[row][col] := &quot;.&quot;; // Now unblock this square
od od;

table</code></pre>
<p>Notice how the script iterates over the desired positions using the same <code>grid</code> 
for efficiency.</p>
<p>Several more sophisticated examples are included in the <code>examples</code> 
directory of the cgsuite distribution.&nbsp; You can run them directly using the 
&quot;Run Script ...&quot; command from the File menu.</p>
<h3><a name="Exercises"></a>Exercises</h3>


<p>1. <i>Partizan End Nim.</i>&nbsp; Partizan end nim is played with <i>n</i> 
nim heaps arranged in linear order.&nbsp; Left, on his turn, may remove any 
number of beans from the leftmost non-empty heap; right, from the rightmost.&nbsp; 
We can represent partizan end nim positions as lists in cgsuite.&nbsp; For 
example, Left's options from <code>[2,3,1]</code> are to <code>[1,3,1]</code> 
and <code>[3,1]</code>; Right's only option is to <code>[2,3]</code>.&nbsp; 
Write a procedure <code>pendnim</code> that takes a list as input and calculates 
the value of the corresponding position in partizan end nim.&nbsp; (You might 
find it easiest to use the list-manipulation methods <code>Remove</code> and <code>Clone</code>.)&nbsp; 
Then construct a table showing the values of <code>[m,n]</code> for <code>1 &lt;= m,n &lt;= 6</code>.</p>


<hr>
Continue on to <a href="Impartial Games.cgsh.html">Impartial Games</a></body></html>